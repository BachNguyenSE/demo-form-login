"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jest-diff";
exports.ids = ["vendor-chunks/jest-diff"];
exports.modules = {

/***/ "(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js":
/*!*********************************************************!*\
  !*** ./node_modules/jest-diff/build/cleanupSemantic.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.cleanupSemantic =\n  exports.Diff =\n  exports.DIFF_INSERT =\n  exports.DIFF_EQUAL =\n  exports.DIFF_DELETE =\n    void 0;\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nexports.DIFF_DELETE = DIFF_DELETE;\nvar DIFF_INSERT = 1;\nexports.DIFF_INSERT = DIFF_INSERT;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\nexports.DIFF_EQUAL = DIFF_EQUAL;\nclass Diff {\n  0;\n  1;\n  constructor(op, text) {\n    this[0] = op;\n    this[1] = text;\n  }\n}\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nexports.Diff = Diff;\nvar diff_commonPrefix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nvar diff_commonSuffix = function (text1, text2) {\n  // Quick check for common null cases.\n  if (\n    !text1 ||\n    !text2 ||\n    text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)\n  ) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\nvar diff_commonOverlap_ = function (text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (\n      found == 0 ||\n      text1.substring(text_length - length) == text2.substring(0, length)\n    ) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupSemantic = function (diffs) {\n  var changes = false;\n  var equalities = []; // Stack of indices where equalities are found.\n  var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0; // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {\n      // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (\n        lastEquality &&\n        lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1) &&\n        lastEquality.length <= Math.max(length_insertions2, length_deletions2)\n      ) {\n        // Duplicate record.\n        diffs.splice(\n          equalities[equalitiesLength - 1],\n          0,\n          new Diff(DIFF_DELETE, lastEquality)\n        );\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0; // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n  diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (\n      diffs[pointer - 1][0] == DIFF_DELETE &&\n      diffs[pointer][0] == DIFF_INSERT\n    ) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (\n          overlap_length1 >= deletion.length / 2 ||\n          overlap_length1 >= insertion.length / 2\n        ) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))\n          );\n          diffs[pointer - 1][1] = deletion.substring(\n            0,\n            deletion.length - overlap_length1\n          );\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (\n          overlap_length2 >= deletion.length / 2 ||\n          overlap_length2 >= insertion.length / 2\n        ) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(\n            pointer,\n            0,\n            new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))\n          );\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(\n            0,\n            insertion.length - overlap_length2\n          );\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nexports.cleanupSemantic = diff_cleanupSemantic;\nvar diff_cleanupSemanticLossless = function (diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore =\n        diff_cleanupSemanticScore_(equality1, edit) +\n        diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score =\n          diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupMerge = function (diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (\n                pointer - count_delete - count_insert > 0 &&\n                diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL\n              ) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                  text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(\n                  0,\n                  0,\n                  new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))\n                );\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) +\n                diffs[pointer][1];\n              text_insert = text_insert.substring(\n                0,\n                text_insert.length - commonlength\n              );\n              text_delete = text_delete.substring(\n                0,\n                text_delete.length - commonlength\n              );\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop(); // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (\n      diffs[pointer - 1][0] == DIFF_EQUAL &&\n      diffs[pointer + 1][0] == DIFF_EQUAL\n    ) {\n      // This is a single edit surrounded by equalities.\n      if (\n        diffs[pointer][1].substring(\n          diffs[pointer][1].length - diffs[pointer - 1][1].length\n        ) == diffs[pointer - 1][1]\n      ) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] =\n          diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(\n            0,\n            diffs[pointer][1].length - diffs[pointer - 1][1].length\n          );\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (\n        diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]\n      ) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2NsZWFudXBTZW1hbnRpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix1QkFBdUI7QUFDdkIsRUFBRSxZQUFZO0FBQ2QsRUFBRSxtQkFBbUI7QUFDckIsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSxtQkFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVtby1sb2dpbi8uL25vZGVfbW9kdWxlcy9qZXN0LWRpZmYvYnVpbGQvY2xlYW51cFNlbWFudGljLmpzP2VlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xlYW51cFNlbWFudGljID1cbiAgZXhwb3J0cy5EaWZmID1cbiAgZXhwb3J0cy5ESUZGX0lOU0VSVCA9XG4gIGV4cG9ydHMuRElGRl9FUVVBTCA9XG4gIGV4cG9ydHMuRElGRl9ERUxFVEUgPVxuICAgIHZvaWQgMDtcbi8qKlxuICogRGlmZiBNYXRjaCBhbmQgUGF0Y2hcbiAqIENvcHlyaWdodCAyMDE4IFRoZSBkaWZmLW1hdGNoLXBhdGNoIEF1dGhvcnMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2RpZmYtbWF0Y2gtcGF0Y2hcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0ZXh0cyB0byBjcmVhdGUgYSBwYXRjaC5cbiAqIEFwcGxpZXMgdGhlIHBhdGNoIG9udG8gYW5vdGhlciB0ZXh0LCBhbGxvd2luZyBmb3IgZXJyb3JzLlxuICogQGF1dGhvciBmcmFzZXJAZ29vZ2xlLmNvbSAoTmVpbCBGcmFzZXIpXG4gKi9cblxuLyoqXG4gKiBDSEFOR0VTIGJ5IHBlZHJvdHRpbWFyayB0byBkaWZmX21hdGNoX3BhdGNoX3VuY29tcHJlc3NlZC50cyBmaWxlOlxuICpcbiAqIDEuIERlbGV0ZSBhbnl0aGluZyBub3QgbmVlZGVkIHRvIHVzZSBkaWZmX2NsZWFudXBTZW1hbnRpYyBtZXRob2RcbiAqIDIuIENvbnZlcnQgZnJvbSBwcm90b3R5cGUgcHJvcGVydGllcyB0byB2YXIgZGVjbGFyYXRpb25zXG4gKiAzLiBDb252ZXJ0IERpZmYgdG8gY2xhc3MgZnJvbSBjb25zdHJ1Y3RvciBhbmQgcHJvdG90eXBlXG4gKiA0LiBBZGQgdHlwZSBhbm5vdGF0aW9ucyBmb3IgYXJndW1lbnRzIGFuZCByZXR1cm4gdmFsdWVzXG4gKiA1LiBBZGQgZXhwb3J0c1xuICovXG5cbi8qKlxuICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXG4gKi9cbnZhciBESUZGX0RFTEVURSA9IC0xO1xuZXhwb3J0cy5ESUZGX0RFTEVURSA9IERJRkZfREVMRVRFO1xudmFyIERJRkZfSU5TRVJUID0gMTtcbmV4cG9ydHMuRElGRl9JTlNFUlQgPSBESUZGX0lOU0VSVDtcbnZhciBESUZGX0VRVUFMID0gMDtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIGRpZmYgdHVwbGUuXG4gKiBBdHRlbXB0cyB0byBsb29rIGxpa2UgYSB0d28tZWxlbWVudCBhcnJheSAod2hpY2ggaXMgd2hhdCB0aGlzIHVzZWQgdG8gYmUpLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wIE9wZXJhdGlvbiwgb25lIG9mOiBESUZGX0RFTEVURSwgRElGRl9JTlNFUlQsIERJRkZfRVFVQUwuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHRvIGJlIGRlbGV0ZWQsIGluc2VydGVkLCBvciByZXRhaW5lZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLkRJRkZfRVFVQUwgPSBESUZGX0VRVUFMO1xuY2xhc3MgRGlmZiB7XG4gIDA7XG4gIDE7XG4gIGNvbnN0cnVjdG9yKG9wLCB0ZXh0KSB7XG4gICAgdGhpc1swXSA9IG9wO1xuICAgIHRoaXNbMV0gPSB0ZXh0O1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBzdGFydCBvZiBlYWNoXG4gKiAgICAgc3RyaW5nLlxuICovXG5leHBvcnRzLkRpZmYgPSBEaWZmO1xudmFyIGRpZmZfY29tbW9uUHJlZml4ID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPSB0ZXh0Mi5jaGFyQXQoMCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICAvLyBCaW5hcnkgc2VhcmNoLlxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cHM6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKFxuICAgICAgdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT1cbiAgICAgIHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpXG4gICAgKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cbiAqL1xudmFyIGRpZmZfY29tbW9uU3VmZml4ID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmIChcbiAgICAhdGV4dDEgfHxcbiAgICAhdGV4dDIgfHxcbiAgICB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0gMSkgIT0gdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIDEpXG4gICkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIHZhciBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKFxuICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09XG4gICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZClcbiAgICApIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHN1ZmZpeCBvZiBvbmUgc3RyaW5nIGlzIHRoZSBwcmVmaXggb2YgYW5vdGhlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdFxuICogICAgIHN0cmluZyBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xudmFyIGRpZmZfY29tbW9uT3ZlcmxhcF8gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgLy8gRWxpbWluYXRlIHRoZSBudWxsIGNhc2UuXG4gIGlmICh0ZXh0MV9sZW5ndGggPT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIFRydW5jYXRlIHRoZSBsb25nZXIgc3RyaW5nLlxuICBpZiAodGV4dDFfbGVuZ3RoID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0ZXh0MV9sZW5ndGggPCB0ZXh0Ml9sZW5ndGgpIHtcbiAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGgpO1xuICB9XG4gIHZhciB0ZXh0X2xlbmd0aCA9IE1hdGgubWluKHRleHQxX2xlbmd0aCwgdGV4dDJfbGVuZ3RoKTtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIHRoZSB3b3JzdCBjYXNlLlxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICByZXR1cm4gdGV4dF9sZW5ndGg7XG4gIH1cblxuICAvLyBTdGFydCBieSBsb29raW5nIGZvciBhIHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hcbiAgLy8gYW5kIGluY3JlYXNlIGxlbmd0aCB1bnRpbCBubyBtYXRjaCBpcyBmb3VuZC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMTAvMTEvMDQvXG4gIHZhciBiZXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IDE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpO1xuICAgIHZhciBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG4gICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICByZXR1cm4gYmVzdDtcbiAgICB9XG4gICAgbGVuZ3RoICs9IGZvdW5kO1xuICAgIGlmIChcbiAgICAgIGZvdW5kID09IDAgfHxcbiAgICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0X2xlbmd0aCAtIGxlbmd0aCkgPT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aClcbiAgICApIHtcbiAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICBsZW5ndGgrKztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgc2VtYW50aWNhbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbnZhciBkaWZmX2NsZWFudXBTZW1hbnRpYyA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7IC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICB2YXIgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgLy8gQWx3YXlzIGVxdWFsIHRvIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7IC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBwcmlvciB0byB0aGUgZXF1YWxpdHkuXG4gIHZhciBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwO1xuICB2YXIgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgYWZ0ZXIgdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgdmFyIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gRXF1YWxpdHkgZm91bmQuXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gbGVuZ3RoX2luc2VydGlvbnMyO1xuICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSBsZW5ndGhfZGVsZXRpb25zMjtcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBFbGltaW5hdGUgYW4gZXF1YWxpdHkgdGhhdCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBlZGl0cyBvbiBib3RoXG4gICAgICAvLyBzaWRlcyBvZiBpdC5cbiAgICAgIGlmIChcbiAgICAgICAgbGFzdEVxdWFsaXR5ICYmXG4gICAgICAgIGxhc3RFcXVhbGl0eS5sZW5ndGggPD1cbiAgICAgICAgICBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczEsIGxlbmd0aF9kZWxldGlvbnMxKSAmJlxuICAgICAgICBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMiwgbGVuZ3RoX2RlbGV0aW9uczIpXG4gICAgICApIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZC5cbiAgICAgICAgZGlmZnMuc3BsaWNlKFxuICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbmV3IERpZmYoRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eSlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwOyAvLyBSZXNldCB0aGUgY291bnRlcnMuXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICAgICAgICBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBkaWZmLlxuICBpZiAoY2hhbmdlcykge1xuICAgIGRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxuICBkaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcblxuICAvLyBGaW5kIGFueSBvdmVybGFwcyBiZXR3ZWVuIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucy5cbiAgLy8gZS5nOiA8ZGVsPmFiY3h4eDwvZGVsPjxpbnM+eHh4ZGVmPC9pbnM+XG4gIC8vICAgLT4gPGRlbD5hYmM8L2RlbD54eHg8aW5zPmRlZjwvaW5zPlxuICAvLyBlLmc6IDxkZWw+eHh4YWJjPC9kZWw+PGlucz5kZWZ4eHg8L2lucz5cbiAgLy8gICAtPiA8aW5zPmRlZjwvaW5zPnh4eDxkZWw+YWJjPC9kZWw+XG4gIC8vIE9ubHkgZXh0cmFjdCBhbiBvdmVybGFwIGlmIGl0IGlzIGFzIGJpZyBhcyB0aGUgZWRpdCBhaGVhZCBvciBiZWhpbmQgaXQuXG4gIHBvaW50ZXIgPSAxO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChcbiAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0RFTEVURSAmJlxuICAgICAgZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9JTlNFUlRcbiAgICApIHtcbiAgICAgIHZhciBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgIHZhciBpbnNlcnRpb24gPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDEgPSBkaWZmX2NvbW1vbk92ZXJsYXBfKGRlbGV0aW9uLCBpbnNlcnRpb24pO1xuICAgICAgdmFyIG92ZXJsYXBfbGVuZ3RoMiA9IGRpZmZfY29tbW9uT3ZlcmxhcF8oaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IG92ZXJsYXBfbGVuZ3RoMikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgb3ZlcmxhcF9sZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcbiAgICAgICAgICBvdmVybGFwX2xlbmd0aDEgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gT3ZlcmxhcCBmb3VuZC4gIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBuZXcgRGlmZihESUZGX0VRVUFMLCBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBfbGVuZ3RoMSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgZGVsZXRpb24ubGVuZ3RoIC0gb3ZlcmxhcF9sZW5ndGgxXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBpbnNlcnRpb24uc3Vic3RyaW5nKG92ZXJsYXBfbGVuZ3RoMSk7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgb3ZlcmxhcF9sZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcbiAgICAgICAgICBvdmVybGFwX2xlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gUmV2ZXJzZSBvdmVybGFwIGZvdW5kLlxuICAgICAgICAgIC8vIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgc3dhcCBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKFxuICAgICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBuZXcgRGlmZihESUZGX0VRVUFMLCBkZWxldGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgyKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBfbGVuZ3RoMlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBfbGVuZ3RoMik7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb2ludGVyKys7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxufTtcblxuLyoqXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZXhwb3J0cy5jbGVhbnVwU2VtYW50aWMgPSBkaWZmX2NsZWFudXBTZW1hbnRpYztcbnZhciBkaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gIC8qKlxuICAgKiBHaXZlbiB0d28gc3RyaW5ncywgY29tcHV0ZSBhIHNjb3JlIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBpbnRlcm5hbFxuICAgKiBib3VuZGFyeSBmYWxscyBvbiBsb2dpY2FsIGJvdW5kYXJpZXMuXG4gICAqIFNjb3JlcyByYW5nZSBmcm9tIDYgKGJlc3QpIHRvIDAgKHdvcnN0KS5cbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgcmV0dXJuIDY7XG4gICAgfVxuXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cbiAgICAvLyBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gZWFjaCBsYW5ndWFnZSdzIGRlZmluaXRpb24gb2YgdGhpbmdzIGxpa2VcbiAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xuICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXG4gICAgdmFyIGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGNoYXIyID0gdHdvLmNoYXJBdCgwKTtcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4Xyk7XG4gICAgdmFyIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgIHZhciB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2god2hpdGVzcGFjZVJlZ2V4Xyk7XG4gICAgdmFyIHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJiBjaGFyMi5tYXRjaCh3aGl0ZXNwYWNlUmVnZXhfKTtcbiAgICB2YXIgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmIGNoYXIxLm1hdGNoKGxpbmVicmVha1JlZ2V4Xyk7XG4gICAgdmFyIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChsaW5lYnJlYWtSZWdleF8pO1xuICAgIHZhciBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJiBvbmUubWF0Y2goYmxhbmtsaW5lRW5kUmVnZXhfKTtcbiAgICB2YXIgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0UmVnZXhfKTtcbiAgICBpZiAoYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyKSB7XG4gICAgICAvLyBGaXZlIHBvaW50cyBmb3IgYmxhbmsgbGluZXMuXG4gICAgICByZXR1cm4gNTtcbiAgICB9IGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xuICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGxpbmUgYnJlYWtzLlxuICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xuICAgICAgLy8gVGhyZWUgcG9pbnRzIGZvciBlbmQgb2Ygc2VudGVuY2VzLlxuICAgICAgcmV0dXJuIDM7XG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMikge1xuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyKSB7XG4gICAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHBvaW50ZXIgPSAxO1xuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChcbiAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTFxuICAgICkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIHZhciBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICB2YXIgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcblxuICAgICAgLy8gRmlyc3QsIHNoaWZ0IHRoZSBlZGl0IGFzIGZhciBsZWZ0IGFzIHBvc3NpYmxlLlxuICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IGRpZmZfY29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIHZhciBjb21tb25TdHJpbmcgPSBlZGl0LnN1YnN0cmluZyhlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgIGVkaXQgPSBjb21tb25TdHJpbmcgKyBlZGl0LnN1YnN0cmluZygwLCBlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgIGVxdWFsaXR5MiA9IGNvbW1vblN0cmluZyArIGVxdWFsaXR5MjtcbiAgICAgIH1cblxuICAgICAgLy8gU2Vjb25kLCBzdGVwIGNoYXJhY3RlciBieSBjaGFyYWN0ZXIgcmlnaHQsIGxvb2tpbmcgZm9yIHRoZSBiZXN0IGZpdC5cbiAgICAgIHZhciBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgdmFyIGJlc3RFZGl0ID0gZWRpdDtcbiAgICAgIHZhciBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgdmFyIGJlc3RTY29yZSA9XG4gICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcbiAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgdmFyIHNjb3JlID1cbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXG4gICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpIHtcbiAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xuICAgICAgICAgIGJlc3RFZGl0ID0gZWRpdDtcbiAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9IGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbXByb3ZlbWVudCwgc2F2ZSBpdCBiYWNrIHRvIHRoZSBkaWZmLlxuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGJlc3RFcXVhbGl0eTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTIpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxufTtcblxuLy8gRGVmaW5lIHNvbWUgcmVnZXggcGF0dGVybnMgZm9yIG1hdGNoaW5nIGJvdW5kYXJpZXMuXG52YXIgbm9uQWxwaGFOdW1lcmljUmVnZXhfID0gL1teYS16QS1aMC05XS87XG52YXIgd2hpdGVzcGFjZVJlZ2V4XyA9IC9cXHMvO1xudmFyIGxpbmVicmVha1JlZ2V4XyA9IC9bXFxyXFxuXS87XG52YXIgYmxhbmtsaW5lRW5kUmVnZXhfID0gL1xcblxccj9cXG4kLztcbnZhciBibGFua2xpbmVTdGFydFJlZ2V4XyA9IC9eXFxyP1xcblxccj9cXG4vO1xuXG4vKipcbiAqIFJlb3JkZXIgYW5kIG1lcmdlIGxpa2UgZWRpdCBzZWN0aW9ucy4gIE1lcmdlIGVxdWFsaXRpZXMuXG4gKiBBbnkgZWRpdCBzZWN0aW9uIGNhbiBtb3ZlIGFzIGxvbmcgYXMgaXQgZG9lc24ndCBjcm9zcyBhbiBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbnZhciBkaWZmX2NsZWFudXBNZXJnZSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICBkaWZmcy5wdXNoKG5ldyBEaWZmKERJRkZfRVFVQUwsICcnKSk7XG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gIHZhciBjb21tb25sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0ID4gMSkge1xuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25QcmVmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgPiAwICYmXG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XG4gICAgICAgICAgICAgICAgICBESUZGX0VRVUFMXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVsxXSArPVxuICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICBuZXcgRGlmZihESUZGX0VRVUFMLCB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHN1ZmZpeGllcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSArXG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGV4dF9kZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXG4gICAgICAgICAgcG9pbnRlciAtPSBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgaWYgKHRleHRfZGVsZXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIG5ldyBEaWZmKERJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZSkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dF9pbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgbmV3IERpZmYoRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0KSk7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcbiAgICBkaWZmcy5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG5cbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoXG4gICAgICBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxuICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUxcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICBpZiAoXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhcbiAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoXG4gICAgICAgICkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdXG4gICAgICApIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gK1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PVxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV1cbiAgICAgICkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XG4gICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICBkaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/jest-diff/build/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SIMILAR_MESSAGE = exports.NO_DIFF_MESSAGE = void 0;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst NO_DIFF_MESSAGE = 'Compared values have no visual difference.';\nexports.NO_DIFF_MESSAGE = NO_DIFF_MESSAGE;\nconst SIMILAR_MESSAGE =\n  'Compared values serialize to the same structure.\\n' +\n  'Printing internal object structure without calling `toJSON` instead.';\nexports.SIMILAR_MESSAGE = SIMILAR_MESSAGE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RlbW8tbG9naW4vLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2NvbnN0YW50cy5qcz83M2E2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNJTUlMQVJfTUVTU0FHRSA9IGV4cG9ydHMuTk9fRElGRl9NRVNTQUdFID0gdm9pZCAwO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IE5PX0RJRkZfTUVTU0FHRSA9ICdDb21wYXJlZCB2YWx1ZXMgaGF2ZSBubyB2aXN1YWwgZGlmZmVyZW5jZS4nO1xuZXhwb3J0cy5OT19ESUZGX01FU1NBR0UgPSBOT19ESUZGX01FU1NBR0U7XG5jb25zdCBTSU1JTEFSX01FU1NBR0UgPVxuICAnQ29tcGFyZWQgdmFsdWVzIHNlcmlhbGl6ZSB0byB0aGUgc2FtZSBzdHJ1Y3R1cmUuXFxuJyArXG4gICdQcmludGluZyBpbnRlcm5hbCBvYmplY3Qgc3RydWN0dXJlIHdpdGhvdXQgY2FsbGluZyBgdG9KU09OYCBpbnN0ZWFkLic7XG5leHBvcnRzLlNJTUlMQVJfTUVTU0FHRSA9IFNJTUlMQVJfTUVTU0FHRTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/diffLines.js":
/*!***************************************************!*\
  !*** ./node_modules/jest-diff/build/diffLines.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.printDiffLines =\n  exports.diffLinesUnified2 =\n  exports.diffLinesUnified =\n  exports.diffLinesRaw =\n    void 0;\nvar _diffSequences = _interopRequireDefault(__webpack_require__(/*! diff-sequences */ \"(ssr)/./node_modules/diff-sequences/build/index.js\"));\nvar _cleanupSemantic = __webpack_require__(/*! ./cleanupSemantic */ \"(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\");\nvar _joinAlignedDiffs = __webpack_require__(/*! ./joinAlignedDiffs */ \"(ssr)/./node_modules/jest-diff/build/joinAlignedDiffs.js\");\nvar _normalizeDiffOptions = __webpack_require__(/*! ./normalizeDiffOptions */ \"(ssr)/./node_modules/jest-diff/build/normalizeDiffOptions.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst isEmptyString = lines => lines.length === 1 && lines[0].length === 0;\nconst countChanges = diffs => {\n  let a = 0;\n  let b = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        a += 1;\n        break;\n      case _cleanupSemantic.DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a,\n    b\n  };\n};\nconst printAnnotation = (\n  {\n    aAnnotation,\n    aColor,\n    aIndicator,\n    bAnnotation,\n    bColor,\n    bIndicator,\n    includeChangeCounts,\n    omitAnnotationLines\n  },\n  changeCounts\n) => {\n  if (omitAnnotationLines) {\n    return '';\n  }\n  let aRest = '';\n  let bRest = '';\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b);\n\n    // Padding right aligns the ends of the annotations.\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff));\n\n    // Padding left aligns the ends of the counts.\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;\n    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;\n  }\n  const a = `${aIndicator} ${aAnnotation}${aRest}`;\n  const b = `${bIndicator} ${bAnnotation}${bRest}`;\n  return `${aColor(a)}\\n${bColor(b)}\\n\\n`;\n};\nconst printDiffLines = (diffs, options) =>\n  printAnnotation(options, countChanges(diffs)) +\n  (options.expand\n    ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options)\n    : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options));\n\n// Compare two arrays of strings line-by-line. Format as comparison lines.\nexports.printDiffLines = printDiffLines;\nconst diffLinesUnified = (aLines, bLines, options) =>\n  printDiffLines(\n    diffLinesRaw(\n      isEmptyString(aLines) ? [] : aLines,\n      isEmptyString(bLines) ? [] : bLines\n    ),\n    (0, _normalizeDiffOptions.normalizeDiffOptions)(options)\n  );\n\n// Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\nexports.diffLinesUnified = diffLinesUnified;\nconst diffLinesUnified2 = (\n  aLinesDisplay,\n  bLinesDisplay,\n  aLinesCompare,\n  bLinesCompare,\n  options\n) => {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n  if (\n    aLinesDisplay.length !== aLinesCompare.length ||\n    bLinesDisplay.length !== bLinesCompare.length\n  ) {\n    // Fall back to diff of display lines.\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n  const diffs = diffLinesRaw(aLinesCompare, bLinesCompare);\n\n  // Replace comparison lines with displayable lines.\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        diff[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n      case _cleanupSemantic.DIFF_INSERT:\n        diff[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n      default:\n        diff[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return printDiffLines(\n    diffs,\n    (0, _normalizeDiffOptions.normalizeDiffOptions)(options)\n  );\n};\n\n// Compare two arrays of strings line-by-line.\nexports.diffLinesUnified2 = diffLinesUnified2;\nconst diffLinesRaw = (aLines, bLines) => {\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(\n        new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex])\n      );\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(\n        new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex])\n      );\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(\n        new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex])\n      );\n    }\n  };\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(\n      new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex])\n    );\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(\n      new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex])\n    );\n  }\n  return diffs;\n};\nexports.diffLinesRaw = diffLinesRaw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2RpZmZMaW5lcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixzQkFBc0I7QUFDdEIsRUFBRSx5QkFBeUI7QUFDM0IsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRSxvQkFBb0I7QUFDdEI7QUFDQSw0Q0FBNEMsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDcEUsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRCw0QkFBNEIsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDNUQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUIsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLE9BQU87QUFDM0UsZUFBZSxxQkFBcUIsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLE9BQU87QUFDM0U7QUFDQSxlQUFlLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTTtBQUNqRCxlQUFlLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTTtBQUNqRCxZQUFZLFVBQVUsSUFBSSxVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVtby1sb2dpbi8uL25vZGVfbW9kdWxlcy9qZXN0LWRpZmYvYnVpbGQvZGlmZkxpbmVzLmpzPzY4ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucHJpbnREaWZmTGluZXMgPVxuICBleHBvcnRzLmRpZmZMaW5lc1VuaWZpZWQyID1cbiAgZXhwb3J0cy5kaWZmTGluZXNVbmlmaWVkID1cbiAgZXhwb3J0cy5kaWZmTGluZXNSYXcgPVxuICAgIHZvaWQgMDtcbnZhciBfZGlmZlNlcXVlbmNlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnZGlmZi1zZXF1ZW5jZXMnKSk7XG52YXIgX2NsZWFudXBTZW1hbnRpYyA9IHJlcXVpcmUoJy4vY2xlYW51cFNlbWFudGljJyk7XG52YXIgX2pvaW5BbGlnbmVkRGlmZnMgPSByZXF1aXJlKCcuL2pvaW5BbGlnbmVkRGlmZnMnKTtcbnZhciBfbm9ybWFsaXplRGlmZk9wdGlvbnMgPSByZXF1aXJlKCcuL25vcm1hbGl6ZURpZmZPcHRpb25zJyk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge2RlZmF1bHQ6IG9ian07XG59XG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgaXNFbXB0eVN0cmluZyA9IGxpbmVzID0+IGxpbmVzLmxlbmd0aCA9PT0gMSAmJiBsaW5lc1swXS5sZW5ndGggPT09IDA7XG5jb25zdCBjb3VudENoYW5nZXMgPSBkaWZmcyA9PiB7XG4gIGxldCBhID0gMDtcbiAgbGV0IGIgPSAwO1xuICBkaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgIHN3aXRjaCAoZGlmZlswXSkge1xuICAgICAgY2FzZSBfY2xlYW51cFNlbWFudGljLkRJRkZfREVMRVRFOlxuICAgICAgICBhICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfY2xlYW51cFNlbWFudGljLkRJRkZfSU5TRVJUOlxuICAgICAgICBiICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYSxcbiAgICBiXG4gIH07XG59O1xuY29uc3QgcHJpbnRBbm5vdGF0aW9uID0gKFxuICB7XG4gICAgYUFubm90YXRpb24sXG4gICAgYUNvbG9yLFxuICAgIGFJbmRpY2F0b3IsXG4gICAgYkFubm90YXRpb24sXG4gICAgYkNvbG9yLFxuICAgIGJJbmRpY2F0b3IsXG4gICAgaW5jbHVkZUNoYW5nZUNvdW50cyxcbiAgICBvbWl0QW5ub3RhdGlvbkxpbmVzXG4gIH0sXG4gIGNoYW5nZUNvdW50c1xuKSA9PiB7XG4gIGlmIChvbWl0QW5ub3RhdGlvbkxpbmVzKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGxldCBhUmVzdCA9ICcnO1xuICBsZXQgYlJlc3QgPSAnJztcbiAgaWYgKGluY2x1ZGVDaGFuZ2VDb3VudHMpIHtcbiAgICBjb25zdCBhQ291bnQgPSBTdHJpbmcoY2hhbmdlQ291bnRzLmEpO1xuICAgIGNvbnN0IGJDb3VudCA9IFN0cmluZyhjaGFuZ2VDb3VudHMuYik7XG5cbiAgICAvLyBQYWRkaW5nIHJpZ2h0IGFsaWducyB0aGUgZW5kcyBvZiB0aGUgYW5ub3RhdGlvbnMuXG4gICAgY29uc3QgYmFBbm5vdGF0aW9uTGVuZ3RoRGlmZiA9IGJBbm5vdGF0aW9uLmxlbmd0aCAtIGFBbm5vdGF0aW9uLmxlbmd0aDtcbiAgICBjb25zdCBhQW5ub3RhdGlvblBhZGRpbmcgPSAnICcucmVwZWF0KE1hdGgubWF4KDAsIGJhQW5ub3RhdGlvbkxlbmd0aERpZmYpKTtcbiAgICBjb25zdCBiQW5ub3RhdGlvblBhZGRpbmcgPSAnICcucmVwZWF0KE1hdGgubWF4KDAsIC1iYUFubm90YXRpb25MZW5ndGhEaWZmKSk7XG5cbiAgICAvLyBQYWRkaW5nIGxlZnQgYWxpZ25zIHRoZSBlbmRzIG9mIHRoZSBjb3VudHMuXG4gICAgY29uc3QgYmFDb3VudExlbmd0aERpZmYgPSBiQ291bnQubGVuZ3RoIC0gYUNvdW50Lmxlbmd0aDtcbiAgICBjb25zdCBhQ291bnRQYWRkaW5nID0gJyAnLnJlcGVhdChNYXRoLm1heCgwLCBiYUNvdW50TGVuZ3RoRGlmZikpO1xuICAgIGNvbnN0IGJDb3VudFBhZGRpbmcgPSAnICcucmVwZWF0KE1hdGgubWF4KDAsIC1iYUNvdW50TGVuZ3RoRGlmZikpO1xuICAgIGFSZXN0ID0gYCR7YUFubm90YXRpb25QYWRkaW5nfSAgJHthSW5kaWNhdG9yfSAke2FDb3VudFBhZGRpbmd9JHthQ291bnR9YDtcbiAgICBiUmVzdCA9IGAke2JBbm5vdGF0aW9uUGFkZGluZ30gICR7YkluZGljYXRvcn0gJHtiQ291bnRQYWRkaW5nfSR7YkNvdW50fWA7XG4gIH1cbiAgY29uc3QgYSA9IGAke2FJbmRpY2F0b3J9ICR7YUFubm90YXRpb259JHthUmVzdH1gO1xuICBjb25zdCBiID0gYCR7YkluZGljYXRvcn0gJHtiQW5ub3RhdGlvbn0ke2JSZXN0fWA7XG4gIHJldHVybiBgJHthQ29sb3IoYSl9XFxuJHtiQ29sb3IoYil9XFxuXFxuYDtcbn07XG5jb25zdCBwcmludERpZmZMaW5lcyA9IChkaWZmcywgb3B0aW9ucykgPT5cbiAgcHJpbnRBbm5vdGF0aW9uKG9wdGlvbnMsIGNvdW50Q2hhbmdlcyhkaWZmcykpICtcbiAgKG9wdGlvbnMuZXhwYW5kXG4gICAgPyAoMCwgX2pvaW5BbGlnbmVkRGlmZnMuam9pbkFsaWduZWREaWZmc0V4cGFuZCkoZGlmZnMsIG9wdGlvbnMpXG4gICAgOiAoMCwgX2pvaW5BbGlnbmVkRGlmZnMuam9pbkFsaWduZWREaWZmc05vRXhwYW5kKShkaWZmcywgb3B0aW9ucykpO1xuXG4vLyBDb21wYXJlIHR3byBhcnJheXMgb2Ygc3RyaW5ncyBsaW5lLWJ5LWxpbmUuIEZvcm1hdCBhcyBjb21wYXJpc29uIGxpbmVzLlxuZXhwb3J0cy5wcmludERpZmZMaW5lcyA9IHByaW50RGlmZkxpbmVzO1xuY29uc3QgZGlmZkxpbmVzVW5pZmllZCA9IChhTGluZXMsIGJMaW5lcywgb3B0aW9ucykgPT5cbiAgcHJpbnREaWZmTGluZXMoXG4gICAgZGlmZkxpbmVzUmF3KFxuICAgICAgaXNFbXB0eVN0cmluZyhhTGluZXMpID8gW10gOiBhTGluZXMsXG4gICAgICBpc0VtcHR5U3RyaW5nKGJMaW5lcykgPyBbXSA6IGJMaW5lc1xuICAgICksXG4gICAgKDAsIF9ub3JtYWxpemVEaWZmT3B0aW9ucy5ub3JtYWxpemVEaWZmT3B0aW9ucykob3B0aW9ucylcbiAgKTtcblxuLy8gR2l2ZW4gdHdvIHBhaXJzIG9mIGFycmF5cyBvZiBzdHJpbmdzOlxuLy8gQ29tcGFyZSB0aGUgcGFpciBvZiBjb21wYXJpc29uIGFycmF5cyBsaW5lLWJ5LWxpbmUuXG4vLyBGb3JtYXQgdGhlIGNvcnJlc3BvbmRpbmcgbGluZXMgaW4gdGhlIHBhaXIgb2YgZGlzcGxheWFibGUgYXJyYXlzLlxuZXhwb3J0cy5kaWZmTGluZXNVbmlmaWVkID0gZGlmZkxpbmVzVW5pZmllZDtcbmNvbnN0IGRpZmZMaW5lc1VuaWZpZWQyID0gKFxuICBhTGluZXNEaXNwbGF5LFxuICBiTGluZXNEaXNwbGF5LFxuICBhTGluZXNDb21wYXJlLFxuICBiTGluZXNDb21wYXJlLFxuICBvcHRpb25zXG4pID0+IHtcbiAgaWYgKGlzRW1wdHlTdHJpbmcoYUxpbmVzRGlzcGxheSkgJiYgaXNFbXB0eVN0cmluZyhhTGluZXNDb21wYXJlKSkge1xuICAgIGFMaW5lc0Rpc3BsYXkgPSBbXTtcbiAgICBhTGluZXNDb21wYXJlID0gW107XG4gIH1cbiAgaWYgKGlzRW1wdHlTdHJpbmcoYkxpbmVzRGlzcGxheSkgJiYgaXNFbXB0eVN0cmluZyhiTGluZXNDb21wYXJlKSkge1xuICAgIGJMaW5lc0Rpc3BsYXkgPSBbXTtcbiAgICBiTGluZXNDb21wYXJlID0gW107XG4gIH1cbiAgaWYgKFxuICAgIGFMaW5lc0Rpc3BsYXkubGVuZ3RoICE9PSBhTGluZXNDb21wYXJlLmxlbmd0aCB8fFxuICAgIGJMaW5lc0Rpc3BsYXkubGVuZ3RoICE9PSBiTGluZXNDb21wYXJlLmxlbmd0aFxuICApIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gZGlmZiBvZiBkaXNwbGF5IGxpbmVzLlxuICAgIHJldHVybiBkaWZmTGluZXNVbmlmaWVkKGFMaW5lc0Rpc3BsYXksIGJMaW5lc0Rpc3BsYXksIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGRpZmZzID0gZGlmZkxpbmVzUmF3KGFMaW5lc0NvbXBhcmUsIGJMaW5lc0NvbXBhcmUpO1xuXG4gIC8vIFJlcGxhY2UgY29tcGFyaXNvbiBsaW5lcyB3aXRoIGRpc3BsYXlhYmxlIGxpbmVzLlxuICBsZXQgYUluZGV4ID0gMDtcbiAgbGV0IGJJbmRleCA9IDA7XG4gIGRpZmZzLmZvckVhY2goZGlmZiA9PiB7XG4gICAgc3dpdGNoIChkaWZmWzBdKSB7XG4gICAgICBjYXNlIF9jbGVhbnVwU2VtYW50aWMuRElGRl9ERUxFVEU6XG4gICAgICAgIGRpZmZbMV0gPSBhTGluZXNEaXNwbGF5W2FJbmRleF07XG4gICAgICAgIGFJbmRleCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2NsZWFudXBTZW1hbnRpYy5ESUZGX0lOU0VSVDpcbiAgICAgICAgZGlmZlsxXSA9IGJMaW5lc0Rpc3BsYXlbYkluZGV4XTtcbiAgICAgICAgYkluZGV4ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGlmZlsxXSA9IGJMaW5lc0Rpc3BsYXlbYkluZGV4XTtcbiAgICAgICAgYUluZGV4ICs9IDE7XG4gICAgICAgIGJJbmRleCArPSAxO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcmludERpZmZMaW5lcyhcbiAgICBkaWZmcyxcbiAgICAoMCwgX25vcm1hbGl6ZURpZmZPcHRpb25zLm5vcm1hbGl6ZURpZmZPcHRpb25zKShvcHRpb25zKVxuICApO1xufTtcblxuLy8gQ29tcGFyZSB0d28gYXJyYXlzIG9mIHN0cmluZ3MgbGluZS1ieS1saW5lLlxuZXhwb3J0cy5kaWZmTGluZXNVbmlmaWVkMiA9IGRpZmZMaW5lc1VuaWZpZWQyO1xuY29uc3QgZGlmZkxpbmVzUmF3ID0gKGFMaW5lcywgYkxpbmVzKSA9PiB7XG4gIGNvbnN0IGFMZW5ndGggPSBhTGluZXMubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYkxpbmVzLmxlbmd0aDtcbiAgY29uc3QgaXNDb21tb24gPSAoYUluZGV4LCBiSW5kZXgpID0+IGFMaW5lc1thSW5kZXhdID09PSBiTGluZXNbYkluZGV4XTtcbiAgY29uc3QgZGlmZnMgPSBbXTtcbiAgbGV0IGFJbmRleCA9IDA7XG4gIGxldCBiSW5kZXggPSAwO1xuICBjb25zdCBmb3VuZFN1YnNlcXVlbmNlID0gKG5Db21tb24sIGFDb21tb24sIGJDb21tb24pID0+IHtcbiAgICBmb3IgKDsgYUluZGV4ICE9PSBhQ29tbW9uOyBhSW5kZXggKz0gMSkge1xuICAgICAgZGlmZnMucHVzaChcbiAgICAgICAgbmV3IF9jbGVhbnVwU2VtYW50aWMuRGlmZihfY2xlYW51cFNlbWFudGljLkRJRkZfREVMRVRFLCBhTGluZXNbYUluZGV4XSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoOyBiSW5kZXggIT09IGJDb21tb247IGJJbmRleCArPSAxKSB7XG4gICAgICBkaWZmcy5wdXNoKFxuICAgICAgICBuZXcgX2NsZWFudXBTZW1hbnRpYy5EaWZmKF9jbGVhbnVwU2VtYW50aWMuRElGRl9JTlNFUlQsIGJMaW5lc1tiSW5kZXhdKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICg7IG5Db21tb24gIT09IDA7IG5Db21tb24gLT0gMSwgYUluZGV4ICs9IDEsIGJJbmRleCArPSAxKSB7XG4gICAgICBkaWZmcy5wdXNoKFxuICAgICAgICBuZXcgX2NsZWFudXBTZW1hbnRpYy5EaWZmKF9jbGVhbnVwU2VtYW50aWMuRElGRl9FUVVBTCwgYkxpbmVzW2JJbmRleF0pXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgKDAsIF9kaWZmU2VxdWVuY2VzLmRlZmF1bHQpKGFMZW5ndGgsIGJMZW5ndGgsIGlzQ29tbW9uLCBmb3VuZFN1YnNlcXVlbmNlKTtcblxuICAvLyBBZnRlciB0aGUgbGFzdCBjb21tb24gc3Vic2VxdWVuY2UsIHB1c2ggcmVtYWluaW5nIGNoYW5nZSBpdGVtcy5cbiAgZm9yICg7IGFJbmRleCAhPT0gYUxlbmd0aDsgYUluZGV4ICs9IDEpIHtcbiAgICBkaWZmcy5wdXNoKFxuICAgICAgbmV3IF9jbGVhbnVwU2VtYW50aWMuRGlmZihfY2xlYW51cFNlbWFudGljLkRJRkZfREVMRVRFLCBhTGluZXNbYUluZGV4XSlcbiAgICApO1xuICB9XG4gIGZvciAoOyBiSW5kZXggIT09IGJMZW5ndGg7IGJJbmRleCArPSAxKSB7XG4gICAgZGlmZnMucHVzaChcbiAgICAgIG5ldyBfY2xlYW51cFNlbWFudGljLkRpZmYoX2NsZWFudXBTZW1hbnRpYy5ESUZGX0lOU0VSVCwgYkxpbmVzW2JJbmRleF0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59O1xuZXhwb3J0cy5kaWZmTGluZXNSYXcgPSBkaWZmTGluZXNSYXc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/diffLines.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/diffStrings.js":
/*!*****************************************************!*\
  !*** ./node_modules/jest-diff/build/diffStrings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _diffSequences = _interopRequireDefault(__webpack_require__(/*! diff-sequences */ \"(ssr)/./node_modules/diff-sequences/build/index.js\"));\nvar _cleanupSemantic = __webpack_require__(/*! ./cleanupSemantic */ \"(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst diffStrings = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n  let aIndex = 0;\n  let bIndex = 0;\n  const diffs = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      diffs.push(\n        new _cleanupSemantic.Diff(\n          _cleanupSemantic.DIFF_DELETE,\n          a.slice(aIndex, aCommon)\n        )\n      );\n    }\n    if (bIndex !== bCommon) {\n      diffs.push(\n        new _cleanupSemantic.Diff(\n          _cleanupSemantic.DIFF_INSERT,\n          b.slice(bIndex, bCommon)\n        )\n      );\n    }\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    diffs.push(\n      new _cleanupSemantic.Diff(\n        _cleanupSemantic.DIFF_EQUAL,\n        b.slice(bCommon, bIndex)\n      )\n    );\n  };\n  (0, _diffSequences.default)(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    diffs.push(\n      new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, a.slice(aIndex))\n    );\n  }\n  if (bIndex !== b.length) {\n    diffs.push(\n      new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, b.slice(bIndex))\n    );\n  }\n  return diffs;\n};\nvar _default = diffStrings;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2RpZmZTdHJpbmdzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsNENBQTRDLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3BFLHVCQUF1QixtQkFBTyxDQUFDLGtGQUFtQjtBQUNsRDtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZW1vLWxvZ2luLy4vbm9kZV9tb2R1bGVzL2plc3QtZGlmZi9idWlsZC9kaWZmU3RyaW5ncy5qcz84ZDdhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RpZmZTZXF1ZW5jZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ2RpZmYtc2VxdWVuY2VzJykpO1xudmFyIF9jbGVhbnVwU2VtYW50aWMgPSByZXF1aXJlKCcuL2NsZWFudXBTZW1hbnRpYycpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtkZWZhdWx0OiBvYmp9O1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IGRpZmZTdHJpbmdzID0gKGEsIGIpID0+IHtcbiAgY29uc3QgaXNDb21tb24gPSAoYUluZGV4LCBiSW5kZXgpID0+IGFbYUluZGV4XSA9PT0gYltiSW5kZXhdO1xuICBsZXQgYUluZGV4ID0gMDtcbiAgbGV0IGJJbmRleCA9IDA7XG4gIGNvbnN0IGRpZmZzID0gW107XG4gIGNvbnN0IGZvdW5kU3Vic2VxdWVuY2UgPSAobkNvbW1vbiwgYUNvbW1vbiwgYkNvbW1vbikgPT4ge1xuICAgIGlmIChhSW5kZXggIT09IGFDb21tb24pIHtcbiAgICAgIGRpZmZzLnB1c2goXG4gICAgICAgIG5ldyBfY2xlYW51cFNlbWFudGljLkRpZmYoXG4gICAgICAgICAgX2NsZWFudXBTZW1hbnRpYy5ESUZGX0RFTEVURSxcbiAgICAgICAgICBhLnNsaWNlKGFJbmRleCwgYUNvbW1vbilcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGJJbmRleCAhPT0gYkNvbW1vbikge1xuICAgICAgZGlmZnMucHVzaChcbiAgICAgICAgbmV3IF9jbGVhbnVwU2VtYW50aWMuRGlmZihcbiAgICAgICAgICBfY2xlYW51cFNlbWFudGljLkRJRkZfSU5TRVJULFxuICAgICAgICAgIGIuc2xpY2UoYkluZGV4LCBiQ29tbW9uKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBhSW5kZXggPSBhQ29tbW9uICsgbkNvbW1vbjsgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tcGFyZWQgaW4gYVxuICAgIGJJbmRleCA9IGJDb21tb24gKyBuQ29tbW9uOyAvLyBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21wYXJlZCBpbiBiXG4gICAgZGlmZnMucHVzaChcbiAgICAgIG5ldyBfY2xlYW51cFNlbWFudGljLkRpZmYoXG4gICAgICAgIF9jbGVhbnVwU2VtYW50aWMuRElGRl9FUVVBTCxcbiAgICAgICAgYi5zbGljZShiQ29tbW9uLCBiSW5kZXgpXG4gICAgICApXG4gICAgKTtcbiAgfTtcbiAgKDAsIF9kaWZmU2VxdWVuY2VzLmRlZmF1bHQpKGEubGVuZ3RoLCBiLmxlbmd0aCwgaXNDb21tb24sIGZvdW5kU3Vic2VxdWVuY2UpO1xuXG4gIC8vIEFmdGVyIHRoZSBsYXN0IGNvbW1vbiBzdWJzZXF1ZW5jZSwgcHVzaCByZW1haW5pbmcgY2hhbmdlIGl0ZW1zLlxuICBpZiAoYUluZGV4ICE9PSBhLmxlbmd0aCkge1xuICAgIGRpZmZzLnB1c2goXG4gICAgICBuZXcgX2NsZWFudXBTZW1hbnRpYy5EaWZmKF9jbGVhbnVwU2VtYW50aWMuRElGRl9ERUxFVEUsIGEuc2xpY2UoYUluZGV4KSlcbiAgICApO1xuICB9XG4gIGlmIChiSW5kZXggIT09IGIubGVuZ3RoKSB7XG4gICAgZGlmZnMucHVzaChcbiAgICAgIG5ldyBfY2xlYW51cFNlbWFudGljLkRpZmYoX2NsZWFudXBTZW1hbnRpYy5ESUZGX0lOU0VSVCwgYi5zbGljZShiSW5kZXgpKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufTtcbnZhciBfZGVmYXVsdCA9IGRpZmZTdHJpbmdzO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/diffStrings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/getAlignedDiffs.js":
/*!*********************************************************!*\
  !*** ./node_modules/jest-diff/build/getAlignedDiffs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _cleanupSemantic = __webpack_require__(/*! ./cleanupSemantic */ \"(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (op, diffs, changeColor) =>\n  diffs.reduce(\n    (reduced, diff) =>\n      reduced +\n      (diff[0] === _cleanupSemantic.DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op && diff[1].length !== 0 // empty if change is newline\n        ? changeColor(diff[1])\n        : ''),\n    ''\n  );\n\n// Encapsulate change lines until either a common newline or the end.\nclass ChangeBuffer {\n  op;\n  line; // incomplete line\n  lines; // complete lines\n  changeColor;\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(\n      this.line.length !== 1\n        ? new _cleanupSemantic.Diff(\n            this.op,\n            concatenateRelevantDiffs(this.op, this.line, this.changeColor)\n          )\n        : this.line[0][0] === this.op\n        ? this.line[0] // can use instance\n        : new _cleanupSemantic.Diff(this.op, this.line[0][1]) // was common diff\n    );\n\n    this.line.length = 0;\n  }\n  isLineEmpty() {\n    return this.line.length === 0;\n  }\n\n  // Minor input to buffer.\n  pushDiff(diff) {\n    this.line.push(diff);\n  }\n\n  // Main input to buffer.\n  align(diff) {\n    const string = diff[1];\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  }\n\n  // Output from buffer.\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n}\n\n// Encapsulate common and change lines.\nclass CommonBuffer {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0;\n\n    // An empty diff string is redundant, unless a change line is empty.\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  }\n\n  // Input to buffer.\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n          if (\n            this.deleteBuffer.isLineEmpty() &&\n            this.insertBuffer.isLineEmpty()\n          ) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  }\n\n  // Output from buffer.\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n}\n\n// Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\nconst getAlignedDiffs = (diffs, changeColor) => {\n  const deleteBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_DELETE,\n    changeColor\n  );\n  const insertBuffer = new ChangeBuffer(\n    _cleanupSemantic.DIFF_INSERT,\n    changeColor\n  );\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\nvar _default = getAlignedDiffs;\nexports[\"default\"] = _default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2dldEFsaWduZWREaWZmcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLHVCQUF1QixtQkFBTyxDQUFDLGtGQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVtby1sb2dpbi8uL25vZGVfbW9kdWxlcy9qZXN0LWRpZmYvYnVpbGQvZ2V0QWxpZ25lZERpZmZzLmpzPzY5OTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfY2xlYW51cFNlbWFudGljID0gcmVxdWlyZSgnLi9jbGVhbnVwU2VtYW50aWMnKTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBHaXZlbiBjaGFuZ2Ugb3AgYW5kIGFycmF5IG9mIGRpZmZzLCByZXR1cm4gY29uY2F0ZW5hdGVkIHN0cmluZzpcbi8vICogaW5jbHVkZSBjb21tb24gc3RyaW5nc1xuLy8gKiBpbmNsdWRlIGNoYW5nZSBzdHJpbmdzIHdoaWNoIGhhdmUgYXJndW1lbnQgb3Agd2l0aCBjaGFuZ2VDb2xvclxuLy8gKiBleGNsdWRlIGNoYW5nZSBzdHJpbmdzIHdoaWNoIGhhdmUgb3Bwb3NpdGUgb3BcbmNvbnN0IGNvbmNhdGVuYXRlUmVsZXZhbnREaWZmcyA9IChvcCwgZGlmZnMsIGNoYW5nZUNvbG9yKSA9PlxuICBkaWZmcy5yZWR1Y2UoXG4gICAgKHJlZHVjZWQsIGRpZmYpID0+XG4gICAgICByZWR1Y2VkICtcbiAgICAgIChkaWZmWzBdID09PSBfY2xlYW51cFNlbWFudGljLkRJRkZfRVFVQUxcbiAgICAgICAgPyBkaWZmWzFdXG4gICAgICAgIDogZGlmZlswXSA9PT0gb3AgJiYgZGlmZlsxXS5sZW5ndGggIT09IDAgLy8gZW1wdHkgaWYgY2hhbmdlIGlzIG5ld2xpbmVcbiAgICAgICAgPyBjaGFuZ2VDb2xvcihkaWZmWzFdKVxuICAgICAgICA6ICcnKSxcbiAgICAnJ1xuICApO1xuXG4vLyBFbmNhcHN1bGF0ZSBjaGFuZ2UgbGluZXMgdW50aWwgZWl0aGVyIGEgY29tbW9uIG5ld2xpbmUgb3IgdGhlIGVuZC5cbmNsYXNzIENoYW5nZUJ1ZmZlciB7XG4gIG9wO1xuICBsaW5lOyAvLyBpbmNvbXBsZXRlIGxpbmVcbiAgbGluZXM7IC8vIGNvbXBsZXRlIGxpbmVzXG4gIGNoYW5nZUNvbG9yO1xuICBjb25zdHJ1Y3RvcihvcCwgY2hhbmdlQ29sb3IpIHtcbiAgICB0aGlzLm9wID0gb3A7XG4gICAgdGhpcy5saW5lID0gW107XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMuY2hhbmdlQ29sb3IgPSBjaGFuZ2VDb2xvcjtcbiAgfVxuICBwdXNoU3Vic3RyaW5nKHN1YnN0cmluZykge1xuICAgIHRoaXMucHVzaERpZmYobmV3IF9jbGVhbnVwU2VtYW50aWMuRGlmZih0aGlzLm9wLCBzdWJzdHJpbmcpKTtcbiAgfVxuICBwdXNoTGluZSgpIHtcbiAgICAvLyBBc3N1bWUgY2FsbCBvbmx5IGlmIGxpbmUgaGFzIGF0IGxlYXN0IG9uZSBkaWZmLFxuICAgIC8vIHRoZXJlZm9yZSBhbiBlbXB0eSBsaW5lIG11c3QgaGF2ZSBhIGRpZmYgd2hpY2ggaGFzIGFuIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIElmIGxpbmUgaGFzIG11bHRpcGxlIGRpZmZzLCB0aGVuIGFzc3VtZSBpdCBoYXMgYSBjb21tb24gZGlmZixcbiAgICAvLyB0aGVyZWZvcmUgY2hhbmdlIGRpZmZzIGhhdmUgY2hhbmdlIGNvbG9yO1xuICAgIC8vIG90aGVyd2lzZSB0aGVuIGl0IGhhcyBsaW5lIGNvbG9yIG9ubHkuXG4gICAgdGhpcy5saW5lcy5wdXNoKFxuICAgICAgdGhpcy5saW5lLmxlbmd0aCAhPT0gMVxuICAgICAgICA/IG5ldyBfY2xlYW51cFNlbWFudGljLkRpZmYoXG4gICAgICAgICAgICB0aGlzLm9wLFxuICAgICAgICAgICAgY29uY2F0ZW5hdGVSZWxldmFudERpZmZzKHRoaXMub3AsIHRoaXMubGluZSwgdGhpcy5jaGFuZ2VDb2xvcilcbiAgICAgICAgICApXG4gICAgICAgIDogdGhpcy5saW5lWzBdWzBdID09PSB0aGlzLm9wXG4gICAgICAgID8gdGhpcy5saW5lWzBdIC8vIGNhbiB1c2UgaW5zdGFuY2VcbiAgICAgICAgOiBuZXcgX2NsZWFudXBTZW1hbnRpYy5EaWZmKHRoaXMub3AsIHRoaXMubGluZVswXVsxXSkgLy8gd2FzIGNvbW1vbiBkaWZmXG4gICAgKTtcblxuICAgIHRoaXMubGluZS5sZW5ndGggPSAwO1xuICB9XG4gIGlzTGluZUVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxpbmUubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLy8gTWlub3IgaW5wdXQgdG8gYnVmZmVyLlxuICBwdXNoRGlmZihkaWZmKSB7XG4gICAgdGhpcy5saW5lLnB1c2goZGlmZik7XG4gIH1cblxuICAvLyBNYWluIGlucHV0IHRvIGJ1ZmZlci5cbiAgYWxpZ24oZGlmZikge1xuICAgIGNvbnN0IHN0cmluZyA9IGRpZmZbMV07XG4gICAgaWYgKHN0cmluZy5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgIGNvbnN0IHN1YnN0cmluZ3MgPSBzdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgICAgY29uc3QgaUxhc3QgPSBzdWJzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICBzdWJzdHJpbmdzLmZvckVhY2goKHN1YnN0cmluZywgaSkgPT4ge1xuICAgICAgICBpZiAoaSA8IGlMYXN0KSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHN1YnN0cmluZyBjb21wbGV0ZXMgdGhlIGN1cnJlbnQgY2hhbmdlIGxpbmUuXG4gICAgICAgICAgLy8gQSBtaWRkbGUgc3Vic3RyaW5nIGlzIGEgY2hhbmdlIGxpbmUuXG4gICAgICAgICAgdGhpcy5wdXNoU3Vic3RyaW5nKHN1YnN0cmluZyk7XG4gICAgICAgICAgdGhpcy5wdXNoTGluZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1YnN0cmluZy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBUaGUgbGFzdCBzdWJzdHJpbmcgc3RhcnRzIGEgY2hhbmdlIGxpbmUsIGlmIGl0IGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICAvLyBJbXBvcnRhbnQ6IFRoaXMgbm9uLWVtcHR5IGNvbmRpdGlvbiBhbHNvIGF1dG9tYXRpY2FsbHkgb21pdHNcbiAgICAgICAgICAvLyB0aGUgbmV3bGluZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIGV4cGVjdGVkIGFuZCByZWNlaXZlZCBzdHJpbmdzLlxuICAgICAgICAgIHRoaXMucHVzaFN1YnN0cmluZyhzdWJzdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIG5vbi1tdWx0aWxpbmUgc3RyaW5nIHRvIGN1cnJlbnQgY2hhbmdlIGxpbmUuXG4gICAgICB0aGlzLnB1c2hEaWZmKGRpZmYpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE91dHB1dCBmcm9tIGJ1ZmZlci5cbiAgbW92ZUxpbmVzVG8obGluZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNMaW5lRW1wdHkoKSkge1xuICAgICAgdGhpcy5wdXNoTGluZSgpO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKC4uLnRoaXMubGluZXMpO1xuICAgIHRoaXMubGluZXMubGVuZ3RoID0gMDtcbiAgfVxufVxuXG4vLyBFbmNhcHN1bGF0ZSBjb21tb24gYW5kIGNoYW5nZSBsaW5lcy5cbmNsYXNzIENvbW1vbkJ1ZmZlciB7XG4gIGRlbGV0ZUJ1ZmZlcjtcbiAgaW5zZXJ0QnVmZmVyO1xuICBsaW5lcztcbiAgY29uc3RydWN0b3IoZGVsZXRlQnVmZmVyLCBpbnNlcnRCdWZmZXIpIHtcbiAgICB0aGlzLmRlbGV0ZUJ1ZmZlciA9IGRlbGV0ZUJ1ZmZlcjtcbiAgICB0aGlzLmluc2VydEJ1ZmZlciA9IGluc2VydEJ1ZmZlcjtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gIH1cbiAgcHVzaERpZmZDb21tb25MaW5lKGRpZmYpIHtcbiAgICB0aGlzLmxpbmVzLnB1c2goZGlmZik7XG4gIH1cbiAgcHVzaERpZmZDaGFuZ2VMaW5lcyhkaWZmKSB7XG4gICAgY29uc3QgaXNEaWZmRW1wdHkgPSBkaWZmWzFdLmxlbmd0aCA9PT0gMDtcblxuICAgIC8vIEFuIGVtcHR5IGRpZmYgc3RyaW5nIGlzIHJlZHVuZGFudCwgdW5sZXNzIGEgY2hhbmdlIGxpbmUgaXMgZW1wdHkuXG4gICAgaWYgKCFpc0RpZmZFbXB0eSB8fCB0aGlzLmRlbGV0ZUJ1ZmZlci5pc0xpbmVFbXB0eSgpKSB7XG4gICAgICB0aGlzLmRlbGV0ZUJ1ZmZlci5wdXNoRGlmZihkaWZmKTtcbiAgICB9XG4gICAgaWYgKCFpc0RpZmZFbXB0eSB8fCB0aGlzLmluc2VydEJ1ZmZlci5pc0xpbmVFbXB0eSgpKSB7XG4gICAgICB0aGlzLmluc2VydEJ1ZmZlci5wdXNoRGlmZihkaWZmKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hDaGFuZ2VMaW5lcygpIHtcbiAgICB0aGlzLmRlbGV0ZUJ1ZmZlci5tb3ZlTGluZXNUbyh0aGlzLmxpbmVzKTtcbiAgICB0aGlzLmluc2VydEJ1ZmZlci5tb3ZlTGluZXNUbyh0aGlzLmxpbmVzKTtcbiAgfVxuXG4gIC8vIElucHV0IHRvIGJ1ZmZlci5cbiAgYWxpZ24oZGlmZikge1xuICAgIGNvbnN0IG9wID0gZGlmZlswXTtcbiAgICBjb25zdCBzdHJpbmcgPSBkaWZmWzFdO1xuICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICBjb25zdCBzdWJzdHJpbmdzID0gc3RyaW5nLnNwbGl0KCdcXG4nKTtcbiAgICAgIGNvbnN0IGlMYXN0ID0gc3Vic3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgc3Vic3RyaW5ncy5mb3JFYWNoKChzdWJzdHJpbmcsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBzdWJkaWZmID0gbmV3IF9jbGVhbnVwU2VtYW50aWMuRGlmZihvcCwgc3Vic3RyaW5nKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUJ1ZmZlci5pc0xpbmVFbXB0eSgpICYmXG4gICAgICAgICAgICB0aGlzLmluc2VydEJ1ZmZlci5pc0xpbmVFbXB0eSgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiBib3RoIGN1cnJlbnQgY2hhbmdlIGxpbmVzIGFyZSBlbXB0eSxcbiAgICAgICAgICAgIC8vIHRoZW4gdGhlIGZpcnN0IHN1YnN0cmluZyBpcyBhIGNvbW1vbiBsaW5lLlxuICAgICAgICAgICAgdGhpcy5mbHVzaENoYW5nZUxpbmVzKCk7XG4gICAgICAgICAgICB0aGlzLnB1c2hEaWZmQ29tbW9uTGluZShzdWJkaWZmKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgZWl0aGVyIGN1cnJlbnQgY2hhbmdlIGxpbmUgaXMgbm9uLWVtcHR5LFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgZmlyc3Qgc3Vic3RyaW5nIGNvbXBsZXRlcyB0aGUgY2hhbmdlIGxpbmVzLlxuICAgICAgICAgICAgdGhpcy5wdXNoRGlmZkNoYW5nZUxpbmVzKHN1YmRpZmYpO1xuICAgICAgICAgICAgdGhpcy5mbHVzaENoYW5nZUxpbmVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPCBpTGFzdCkge1xuICAgICAgICAgIC8vIEEgbWlkZGxlIHN1YnN0cmluZyBpcyBhIGNvbW1vbiBsaW5lLlxuICAgICAgICAgIHRoaXMucHVzaERpZmZDb21tb25MaW5lKG5ldyBfY2xlYW51cFNlbWFudGljLkRpZmYob3AsIHN1YnN0cmluZykpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1YnN0cmluZy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBUaGUgbGFzdCBzdWJzdHJpbmcgc3RhcnRzIGEgY2hhbmdlIGxpbmUsIGlmIGl0IGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICAvLyBJbXBvcnRhbnQ6IFRoaXMgbm9uLWVtcHR5IGNvbmRpdGlvbiBhbHNvIGF1dG9tYXRpY2FsbHkgb21pdHNcbiAgICAgICAgICAvLyB0aGUgbmV3bGluZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIGV4cGVjdGVkIGFuZCByZWNlaXZlZCBzdHJpbmdzLlxuICAgICAgICAgIHRoaXMucHVzaERpZmZDaGFuZ2VMaW5lcyhuZXcgX2NsZWFudXBTZW1hbnRpYy5EaWZmKG9wLCBzdWJzdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCBub24tbXVsdGlsaW5lIHN0cmluZyB0byBjdXJyZW50IGNoYW5nZSBsaW5lcy5cbiAgICAgIC8vIEltcG9ydGFudDogSXQgY2Fubm90IGJlIGF0IHRoZSBlbmQgZm9sbG93aW5nIGVtcHR5IGNoYW5nZSBsaW5lcyxcbiAgICAgIC8vIGJlY2F1c2UgbmV3bGluZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIGV4cGVjdGVkIGFuZCByZWNlaXZlZCBzdHJpbmdzLlxuICAgICAgdGhpcy5wdXNoRGlmZkNoYW5nZUxpbmVzKGRpZmYpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE91dHB1dCBmcm9tIGJ1ZmZlci5cbiAgZ2V0TGluZXMoKSB7XG4gICAgdGhpcy5mbHVzaENoYW5nZUxpbmVzKCk7XG4gICAgcmV0dXJuIHRoaXMubGluZXM7XG4gIH1cbn1cblxuLy8gR2l2ZW4gZGlmZnMgZnJvbSBleHBlY3RlZCBhbmQgcmVjZWl2ZWQgc3RyaW5ncyxcbi8vIHJldHVybiBuZXcgYXJyYXkgb2YgZGlmZnMgc3BsaXQgb3Igam9pbmVkIGludG8gbGluZXMuXG4vL1xuLy8gVG8gY29ycmVjdGx5IGFsaWduIGEgY2hhbmdlIGxpbmUgYXQgdGhlIGVuZCwgdGhlIGFsZ29yaXRobTpcbi8vICogYXNzdW1lcyB0aGF0IGEgbmV3bGluZSB3YXMgYXBwZW5kZWQgdG8gdGhlIHN0cmluZ3Ncbi8vICogb21pdHMgdGhlIGxhc3QgbmV3bGluZSBmcm9tIHRoZSBvdXRwdXQgYXJyYXlcbi8vXG4vLyBBc3N1bWUgdGhlIGZ1bmN0aW9uIGlzIG5vdCBjYWxsZWQ6XG4vLyAqIGlmIGVpdGhlciBleHBlY3RlZCBvciByZWNlaXZlZCBpcyBlbXB0eSBzdHJpbmdcbi8vICogaWYgbmVpdGhlciBleHBlY3RlZCBub3IgcmVjZWl2ZWQgaXMgbXVsdGlsaW5lIHN0cmluZ1xuY29uc3QgZ2V0QWxpZ25lZERpZmZzID0gKGRpZmZzLCBjaGFuZ2VDb2xvcikgPT4ge1xuICBjb25zdCBkZWxldGVCdWZmZXIgPSBuZXcgQ2hhbmdlQnVmZmVyKFxuICAgIF9jbGVhbnVwU2VtYW50aWMuRElGRl9ERUxFVEUsXG4gICAgY2hhbmdlQ29sb3JcbiAgKTtcbiAgY29uc3QgaW5zZXJ0QnVmZmVyID0gbmV3IENoYW5nZUJ1ZmZlcihcbiAgICBfY2xlYW51cFNlbWFudGljLkRJRkZfSU5TRVJULFxuICAgIGNoYW5nZUNvbG9yXG4gICk7XG4gIGNvbnN0IGNvbW1vbkJ1ZmZlciA9IG5ldyBDb21tb25CdWZmZXIoZGVsZXRlQnVmZmVyLCBpbnNlcnRCdWZmZXIpO1xuICBkaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgIHN3aXRjaCAoZGlmZlswXSkge1xuICAgICAgY2FzZSBfY2xlYW51cFNlbWFudGljLkRJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGVCdWZmZXIuYWxpZ24oZGlmZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfY2xlYW51cFNlbWFudGljLkRJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRCdWZmZXIuYWxpZ24oZGlmZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29tbW9uQnVmZmVyLmFsaWduKGRpZmYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb21tb25CdWZmZXIuZ2V0TGluZXMoKTtcbn07XG52YXIgX2RlZmF1bHQgPSBnZXRBbGlnbmVkRGlmZnM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/getAlignedDiffs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/index.js":
/*!***********************************************!*\
  !*** ./node_modules/jest-diff/build/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"DIFF_DELETE\", ({\n  enumerable: true,\n  get: function () {\n    return _cleanupSemantic.DIFF_DELETE;\n  }\n}));\nObject.defineProperty(exports, \"DIFF_EQUAL\", ({\n  enumerable: true,\n  get: function () {\n    return _cleanupSemantic.DIFF_EQUAL;\n  }\n}));\nObject.defineProperty(exports, \"DIFF_INSERT\", ({\n  enumerable: true,\n  get: function () {\n    return _cleanupSemantic.DIFF_INSERT;\n  }\n}));\nObject.defineProperty(exports, \"Diff\", ({\n  enumerable: true,\n  get: function () {\n    return _cleanupSemantic.Diff;\n  }\n}));\nexports.diff = diff;\nObject.defineProperty(exports, \"diffLinesRaw\", ({\n  enumerable: true,\n  get: function () {\n    return _diffLines.diffLinesRaw;\n  }\n}));\nObject.defineProperty(exports, \"diffLinesUnified\", ({\n  enumerable: true,\n  get: function () {\n    return _diffLines.diffLinesUnified;\n  }\n}));\nObject.defineProperty(exports, \"diffLinesUnified2\", ({\n  enumerable: true,\n  get: function () {\n    return _diffLines.diffLinesUnified2;\n  }\n}));\nObject.defineProperty(exports, \"diffStringsRaw\", ({\n  enumerable: true,\n  get: function () {\n    return _printDiffs.diffStringsRaw;\n  }\n}));\nObject.defineProperty(exports, \"diffStringsUnified\", ({\n  enumerable: true,\n  get: function () {\n    return _printDiffs.diffStringsUnified;\n  }\n}));\nvar _chalk = _interopRequireDefault(__webpack_require__(/*! chalk */ \"(ssr)/./node_modules/chalk/source/index.js\"));\nvar _jestGetType = __webpack_require__(/*! jest-get-type */ \"(ssr)/./node_modules/jest-get-type/build/index.js\");\nvar _prettyFormat = __webpack_require__(/*! pretty-format */ \"(ssr)/./node_modules/pretty-format/build/index.js\");\nvar _cleanupSemantic = __webpack_require__(/*! ./cleanupSemantic */ \"(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\");\nvar _constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/jest-diff/build/constants.js\");\nvar _diffLines = __webpack_require__(/*! ./diffLines */ \"(ssr)/./node_modules/jest-diff/build/diffLines.js\");\nvar _normalizeDiffOptions = __webpack_require__(/*! ./normalizeDiffOptions */ \"(ssr)/./node_modules/jest-diff/build/normalizeDiffOptions.js\");\nvar _printDiffs = __webpack_require__(/*! ./printDiffs */ \"(ssr)/./node_modules/jest-diff/build/printDiffs.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\nvar Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst getCommonMessage = (message, options) => {\n  const {commonColor} = (0, _normalizeDiffOptions.normalizeDiffOptions)(\n    options\n  );\n  return commonColor(message);\n};\nconst {\n  AsymmetricMatcher,\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent\n} = _prettyFormat.plugins;\nconst PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher\n];\nconst FORMAT_OPTIONS = {\n  plugins: PLUGINS\n};\nconst FALLBACK_FORMAT_OPTIONS = {\n  callToJSON: false,\n  maxDepth: 10,\n  plugins: PLUGINS\n};\n\n// Generate a string that will highlight the difference between two values\n// with green and red. (similar to how github does code diffing)\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction diff(a, b, options) {\n  if (Object.is(a, b)) {\n    return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);\n  }\n  const aType = (0, _jestGetType.getType)(a);\n  let expectedType = aType;\n  let omitDifference = false;\n  if (aType === 'object' && typeof a.asymmetricMatch === 'function') {\n    if (a.$$typeof !== Symbol.for('jest.asymmetricMatcher')) {\n      // Do not know expected type of user-defined asymmetric matcher.\n      return null;\n    }\n    if (typeof a.getExpectedType !== 'function') {\n      // For example, expect.anything() matches either null or undefined\n      return null;\n    }\n    expectedType = a.getExpectedType();\n    // Primitive types boolean and number omit difference below.\n    // For example, omit difference for expect.stringMatching(regexp)\n    omitDifference = expectedType === 'string';\n  }\n  if (expectedType !== (0, _jestGetType.getType)(b)) {\n    return (\n      '  Comparing two different types of values.' +\n      ` Expected ${_chalk.default.green(expectedType)} but ` +\n      `received ${_chalk.default.red((0, _jestGetType.getType)(b))}.`\n    );\n  }\n  if (omitDifference) {\n    return null;\n  }\n  switch (aType) {\n    case 'string':\n      return (0, _diffLines.diffLinesUnified)(\n        a.split('\\n'),\n        b.split('\\n'),\n        options\n      );\n    case 'boolean':\n    case 'number':\n      return comparePrimitive(a, b, options);\n    case 'map':\n      return compareObjects(sortMap(a), sortMap(b), options);\n    case 'set':\n      return compareObjects(sortSet(a), sortSet(b), options);\n    default:\n      return compareObjects(a, b, options);\n  }\n}\nfunction comparePrimitive(a, b, options) {\n  const aFormat = (0, _prettyFormat.format)(a, FORMAT_OPTIONS);\n  const bFormat = (0, _prettyFormat.format)(b, FORMAT_OPTIONS);\n  return aFormat === bFormat\n    ? getCommonMessage(_constants.NO_DIFF_MESSAGE, options)\n    : (0, _diffLines.diffLinesUnified)(\n        aFormat.split('\\n'),\n        bFormat.split('\\n'),\n        options\n      );\n}\nfunction sortMap(map) {\n  return new Map(Array.from(map.entries()).sort());\n}\nfunction sortSet(set) {\n  return new Set(Array.from(set.values()).sort());\n}\nfunction compareObjects(a, b, options) {\n  let difference;\n  let hasThrown = false;\n  try {\n    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a, b, formatOptions, options);\n  } catch {\n    hasThrown = true;\n  }\n  const noDiffMessage = getCommonMessage(_constants.NO_DIFF_MESSAGE, options);\n  // If the comparison yields no results, compare again but this time\n  // without calling `toJSON`. It's also possible that toJSON might throw.\n  if (difference === undefined || difference === noDiffMessage) {\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a, b, formatOptions, options);\n    if (difference !== noDiffMessage && !hasThrown) {\n      difference = `${getCommonMessage(\n        _constants.SIMILAR_MESSAGE,\n        options\n      )}\\n\\n${difference}`;\n    }\n  }\n  return difference;\n}\nfunction getFormatOptions(formatOptions, options) {\n  const {compareKeys} = (0, _normalizeDiffOptions.normalizeDiffOptions)(\n    options\n  );\n  return {\n    ...formatOptions,\n    compareKeys\n  };\n}\nfunction getObjectsDifference(a, b, formatOptions, options) {\n  const formatOptionsZeroIndent = {\n    ...formatOptions,\n    indent: 0\n  };\n  const aCompare = (0, _prettyFormat.format)(a, formatOptionsZeroIndent);\n  const bCompare = (0, _prettyFormat.format)(b, formatOptionsZeroIndent);\n  if (aCompare === bCompare) {\n    return getCommonMessage(_constants.NO_DIFF_MESSAGE, options);\n  } else {\n    const aDisplay = (0, _prettyFormat.format)(a, formatOptions);\n    const bDisplay = (0, _prettyFormat.format)(b, formatOptions);\n    return (0, _diffLines.diffLinesUnified2)(\n      aDisplay.split('\\n'),\n      bDisplay.split('\\n'),\n      aCompare.split('\\n'),\n      bCompare.split('\\n'),\n      options\n    );\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLFlBQVk7QUFDWixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixvREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixxREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixzREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixvQ0FBb0MsbUJBQU8sQ0FBQyx5REFBTztBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZTtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBZTtBQUMzQyx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWE7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWE7QUFDdEMsNEJBQTRCLG1CQUFPLENBQUMsNEZBQXdCO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQsa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFFBQVEsTUFBTSxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RlbW8tbG9naW4vLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2luZGV4LmpzP2I1NzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRElGRl9ERUxFVEUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xlYW51cFNlbWFudGljLkRJRkZfREVMRVRFO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRElGRl9FUVVBTCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jbGVhbnVwU2VtYW50aWMuRElGRl9FUVVBTDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RJRkZfSU5TRVJUJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NsZWFudXBTZW1hbnRpYy5ESUZGX0lOU0VSVDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RpZmYnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xlYW51cFNlbWFudGljLkRpZmY7XG4gIH1cbn0pO1xuZXhwb3J0cy5kaWZmID0gZGlmZjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGlmZkxpbmVzUmF3Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2RpZmZMaW5lcy5kaWZmTGluZXNSYXc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkaWZmTGluZXNVbmlmaWVkJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2RpZmZMaW5lcy5kaWZmTGluZXNVbmlmaWVkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGlmZkxpbmVzVW5pZmllZDInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlmZkxpbmVzLmRpZmZMaW5lc1VuaWZpZWQyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGlmZlN0cmluZ3NSYXcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcHJpbnREaWZmcy5kaWZmU3RyaW5nc1JhdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RpZmZTdHJpbmdzVW5pZmllZCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wcmludERpZmZzLmRpZmZTdHJpbmdzVW5pZmllZDtcbiAgfVxufSk7XG52YXIgX2NoYWxrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCdjaGFsaycpKTtcbnZhciBfamVzdEdldFR5cGUgPSByZXF1aXJlKCdqZXN0LWdldC10eXBlJyk7XG52YXIgX3ByZXR0eUZvcm1hdCA9IHJlcXVpcmUoJ3ByZXR0eS1mb3JtYXQnKTtcbnZhciBfY2xlYW51cFNlbWFudGljID0gcmVxdWlyZSgnLi9jbGVhbnVwU2VtYW50aWMnKTtcbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBfZGlmZkxpbmVzID0gcmVxdWlyZSgnLi9kaWZmTGluZXMnKTtcbnZhciBfbm9ybWFsaXplRGlmZk9wdGlvbnMgPSByZXF1aXJlKCcuL25vcm1hbGl6ZURpZmZPcHRpb25zJyk7XG52YXIgX3ByaW50RGlmZnMgPSByZXF1aXJlKCcuL3ByaW50RGlmZnMnKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ZGVmYXVsdDogb2JqfTtcbn1cbnZhciBTeW1ib2wgPSBnbG9iYWxUaGlzWydqZXN0LXN5bWJvbC1kby1ub3QtdG91Y2gnXSB8fCBnbG9iYWxUaGlzLlN5bWJvbDtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgZ2V0Q29tbW9uTWVzc2FnZSA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtjb21tb25Db2xvcn0gPSAoMCwgX25vcm1hbGl6ZURpZmZPcHRpb25zLm5vcm1hbGl6ZURpZmZPcHRpb25zKShcbiAgICBvcHRpb25zXG4gICk7XG4gIHJldHVybiBjb21tb25Db2xvcihtZXNzYWdlKTtcbn07XG5jb25zdCB7XG4gIEFzeW1tZXRyaWNNYXRjaGVyLFxuICBET01Db2xsZWN0aW9uLFxuICBET01FbGVtZW50LFxuICBJbW11dGFibGUsXG4gIFJlYWN0RWxlbWVudCxcbiAgUmVhY3RUZXN0Q29tcG9uZW50XG59ID0gX3ByZXR0eUZvcm1hdC5wbHVnaW5zO1xuY29uc3QgUExVR0lOUyA9IFtcbiAgUmVhY3RUZXN0Q29tcG9uZW50LFxuICBSZWFjdEVsZW1lbnQsXG4gIERPTUVsZW1lbnQsXG4gIERPTUNvbGxlY3Rpb24sXG4gIEltbXV0YWJsZSxcbiAgQXN5bW1ldHJpY01hdGNoZXJcbl07XG5jb25zdCBGT1JNQVRfT1BUSU9OUyA9IHtcbiAgcGx1Z2luczogUExVR0lOU1xufTtcbmNvbnN0IEZBTExCQUNLX0ZPUk1BVF9PUFRJT05TID0ge1xuICBjYWxsVG9KU09OOiBmYWxzZSxcbiAgbWF4RGVwdGg6IDEwLFxuICBwbHVnaW5zOiBQTFVHSU5TXG59O1xuXG4vLyBHZW5lcmF0ZSBhIHN0cmluZyB0aGF0IHdpbGwgaGlnaGxpZ2h0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHZhbHVlc1xuLy8gd2l0aCBncmVlbiBhbmQgcmVkLiAoc2ltaWxhciB0byBob3cgZ2l0aHViIGRvZXMgY29kZSBkaWZmaW5nKVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGRpZmYoYSwgYiwgb3B0aW9ucykge1xuICBpZiAoT2JqZWN0LmlzKGEsIGIpKSB7XG4gICAgcmV0dXJuIGdldENvbW1vbk1lc3NhZ2UoX2NvbnN0YW50cy5OT19ESUZGX01FU1NBR0UsIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGFUeXBlID0gKDAsIF9qZXN0R2V0VHlwZS5nZXRUeXBlKShhKTtcbiAgbGV0IGV4cGVjdGVkVHlwZSA9IGFUeXBlO1xuICBsZXQgb21pdERpZmZlcmVuY2UgPSBmYWxzZTtcbiAgaWYgKGFUeXBlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYS5hc3ltbWV0cmljTWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoYS4kJHR5cGVvZiAhPT0gU3ltYm9sLmZvcignamVzdC5hc3ltbWV0cmljTWF0Y2hlcicpKSB7XG4gICAgICAvLyBEbyBub3Qga25vdyBleHBlY3RlZCB0eXBlIG9mIHVzZXItZGVmaW5lZCBhc3ltbWV0cmljIG1hdGNoZXIuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhLmdldEV4cGVjdGVkVHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRm9yIGV4YW1wbGUsIGV4cGVjdC5hbnl0aGluZygpIG1hdGNoZXMgZWl0aGVyIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZXhwZWN0ZWRUeXBlID0gYS5nZXRFeHBlY3RlZFR5cGUoKTtcbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgYm9vbGVhbiBhbmQgbnVtYmVyIG9taXQgZGlmZmVyZW5jZSBiZWxvdy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgb21pdCBkaWZmZXJlbmNlIGZvciBleHBlY3Quc3RyaW5nTWF0Y2hpbmcocmVnZXhwKVxuICAgIG9taXREaWZmZXJlbmNlID0gZXhwZWN0ZWRUeXBlID09PSAnc3RyaW5nJztcbiAgfVxuICBpZiAoZXhwZWN0ZWRUeXBlICE9PSAoMCwgX2plc3RHZXRUeXBlLmdldFR5cGUpKGIpKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICcgIENvbXBhcmluZyB0d28gZGlmZmVyZW50IHR5cGVzIG9mIHZhbHVlcy4nICtcbiAgICAgIGAgRXhwZWN0ZWQgJHtfY2hhbGsuZGVmYXVsdC5ncmVlbihleHBlY3RlZFR5cGUpfSBidXQgYCArXG4gICAgICBgcmVjZWl2ZWQgJHtfY2hhbGsuZGVmYXVsdC5yZWQoKDAsIF9qZXN0R2V0VHlwZS5nZXRUeXBlKShiKSl9LmBcbiAgICApO1xuICB9XG4gIGlmIChvbWl0RGlmZmVyZW5jZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuICgwLCBfZGlmZkxpbmVzLmRpZmZMaW5lc1VuaWZpZWQpKFxuICAgICAgICBhLnNwbGl0KCdcXG4nKSxcbiAgICAgICAgYi5zcGxpdCgnXFxuJyksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBjb21wYXJlUHJpbWl0aXZlKGEsIGIsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ21hcCc6XG4gICAgICByZXR1cm4gY29tcGFyZU9iamVjdHMoc29ydE1hcChhKSwgc29ydE1hcChiKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnc2V0JzpcbiAgICAgIHJldHVybiBjb21wYXJlT2JqZWN0cyhzb3J0U2V0KGEpLCBzb3J0U2V0KGIpLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbXBhcmVPYmplY3RzKGEsIGIsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wYXJlUHJpbWl0aXZlKGEsIGIsIG9wdGlvbnMpIHtcbiAgY29uc3QgYUZvcm1hdCA9ICgwLCBfcHJldHR5Rm9ybWF0LmZvcm1hdCkoYSwgRk9STUFUX09QVElPTlMpO1xuICBjb25zdCBiRm9ybWF0ID0gKDAsIF9wcmV0dHlGb3JtYXQuZm9ybWF0KShiLCBGT1JNQVRfT1BUSU9OUyk7XG4gIHJldHVybiBhRm9ybWF0ID09PSBiRm9ybWF0XG4gICAgPyBnZXRDb21tb25NZXNzYWdlKF9jb25zdGFudHMuTk9fRElGRl9NRVNTQUdFLCBvcHRpb25zKVxuICAgIDogKDAsIF9kaWZmTGluZXMuZGlmZkxpbmVzVW5pZmllZCkoXG4gICAgICAgIGFGb3JtYXQuc3BsaXQoJ1xcbicpLFxuICAgICAgICBiRm9ybWF0LnNwbGl0KCdcXG4nKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXAobWFwKSB7XG4gIHJldHVybiBuZXcgTWFwKEFycmF5LmZyb20obWFwLmVudHJpZXMoKSkuc29ydCgpKTtcbn1cbmZ1bmN0aW9uIHNvcnRTZXQoc2V0KSB7XG4gIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20oc2V0LnZhbHVlcygpKS5zb3J0KCkpO1xufVxuZnVuY3Rpb24gY29tcGFyZU9iamVjdHMoYSwgYiwgb3B0aW9ucykge1xuICBsZXQgZGlmZmVyZW5jZTtcbiAgbGV0IGhhc1Rocm93biA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IGZvcm1hdE9wdGlvbnMgPSBnZXRGb3JtYXRPcHRpb25zKEZPUk1BVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBkaWZmZXJlbmNlID0gZ2V0T2JqZWN0c0RpZmZlcmVuY2UoYSwgYiwgZm9ybWF0T3B0aW9ucywgb3B0aW9ucyk7XG4gIH0gY2F0Y2gge1xuICAgIGhhc1Rocm93biA9IHRydWU7XG4gIH1cbiAgY29uc3Qgbm9EaWZmTWVzc2FnZSA9IGdldENvbW1vbk1lc3NhZ2UoX2NvbnN0YW50cy5OT19ESUZGX01FU1NBR0UsIG9wdGlvbnMpO1xuICAvLyBJZiB0aGUgY29tcGFyaXNvbiB5aWVsZHMgbm8gcmVzdWx0cywgY29tcGFyZSBhZ2FpbiBidXQgdGhpcyB0aW1lXG4gIC8vIHdpdGhvdXQgY2FsbGluZyBgdG9KU09OYC4gSXQncyBhbHNvIHBvc3NpYmxlIHRoYXQgdG9KU09OIG1pZ2h0IHRocm93LlxuICBpZiAoZGlmZmVyZW5jZSA9PT0gdW5kZWZpbmVkIHx8IGRpZmZlcmVuY2UgPT09IG5vRGlmZk1lc3NhZ2UpIHtcbiAgICBjb25zdCBmb3JtYXRPcHRpb25zID0gZ2V0Rm9ybWF0T3B0aW9ucyhGQUxMQkFDS19GT1JNQVRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgZGlmZmVyZW5jZSA9IGdldE9iamVjdHNEaWZmZXJlbmNlKGEsIGIsIGZvcm1hdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChkaWZmZXJlbmNlICE9PSBub0RpZmZNZXNzYWdlICYmICFoYXNUaHJvd24pIHtcbiAgICAgIGRpZmZlcmVuY2UgPSBgJHtnZXRDb21tb25NZXNzYWdlKFxuICAgICAgICBfY29uc3RhbnRzLlNJTUlMQVJfTUVTU0FHRSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKX1cXG5cXG4ke2RpZmZlcmVuY2V9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmZlcmVuY2U7XG59XG5mdW5jdGlvbiBnZXRGb3JtYXRPcHRpb25zKGZvcm1hdE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qge2NvbXBhcmVLZXlzfSA9ICgwLCBfbm9ybWFsaXplRGlmZk9wdGlvbnMubm9ybWFsaXplRGlmZk9wdGlvbnMpKFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5mb3JtYXRPcHRpb25zLFxuICAgIGNvbXBhcmVLZXlzXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPYmplY3RzRGlmZmVyZW5jZShhLCBiLCBmb3JtYXRPcHRpb25zLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdE9wdGlvbnNaZXJvSW5kZW50ID0ge1xuICAgIC4uLmZvcm1hdE9wdGlvbnMsXG4gICAgaW5kZW50OiAwXG4gIH07XG4gIGNvbnN0IGFDb21wYXJlID0gKDAsIF9wcmV0dHlGb3JtYXQuZm9ybWF0KShhLCBmb3JtYXRPcHRpb25zWmVyb0luZGVudCk7XG4gIGNvbnN0IGJDb21wYXJlID0gKDAsIF9wcmV0dHlGb3JtYXQuZm9ybWF0KShiLCBmb3JtYXRPcHRpb25zWmVyb0luZGVudCk7XG4gIGlmIChhQ29tcGFyZSA9PT0gYkNvbXBhcmUpIHtcbiAgICByZXR1cm4gZ2V0Q29tbW9uTWVzc2FnZShfY29uc3RhbnRzLk5PX0RJRkZfTUVTU0FHRSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYURpc3BsYXkgPSAoMCwgX3ByZXR0eUZvcm1hdC5mb3JtYXQpKGEsIGZvcm1hdE9wdGlvbnMpO1xuICAgIGNvbnN0IGJEaXNwbGF5ID0gKDAsIF9wcmV0dHlGb3JtYXQuZm9ybWF0KShiLCBmb3JtYXRPcHRpb25zKTtcbiAgICByZXR1cm4gKDAsIF9kaWZmTGluZXMuZGlmZkxpbmVzVW5pZmllZDIpKFxuICAgICAgYURpc3BsYXkuc3BsaXQoJ1xcbicpLFxuICAgICAgYkRpc3BsYXkuc3BsaXQoJ1xcbicpLFxuICAgICAgYUNvbXBhcmUuc3BsaXQoJ1xcbicpLFxuICAgICAgYkNvbXBhcmUuc3BsaXQoJ1xcbicpLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/joinAlignedDiffs.js":
/*!**********************************************************!*\
  !*** ./node_modules/jest-diff/build/joinAlignedDiffs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\nvar _cleanupSemantic = __webpack_require__(/*! ./cleanupSemantic */ \"(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) =>\n  line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\nconst printDiffLine = (\n  line,\n  isFirstOrLast,\n  color,\n  indicator,\n  trailingSpaceFormatter,\n  emptyFirstOrLastLinePlaceholder\n) =>\n  line.length !== 0\n    ? color(\n        `${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`\n      )\n    : indicator !== ' '\n    ? color(indicator)\n    : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0\n    ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`)\n    : '';\nconst printDeleteLine = (\n  line,\n  isFirstOrLast,\n  {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\nconst printInsertLine = (\n  line,\n  isFirstOrLast,\n  {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\nconst printCommonLine = (\n  line,\n  isFirstOrLast,\n  {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\n// In GNU diff format, indexes are one-based instead of zero-based.\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {patchColor}) =>\n  patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  );\n\n// jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines;\n\n  // First pass: count output lines and see if it has patches.\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n  while (i !== iLength) {\n    const iStart = i;\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  }\n\n  // Indexes of expected or received lines in current patch:\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  };\n\n  // Second pass: push lines with diff formatting (and patch marks, if needed).\n  i = 0;\n  while (i !== iLength) {\n    let iStart = i;\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n          lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options\n          );\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n  return lines.join('\\n');\n};\n\n// jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\nconst joinAlignedDiffsExpand = (diffs, options) =>\n  diffs\n    .map((diff, i, diffs) => {\n      const line = diff[1];\n      const isFirstOrLast = i === 0 || i === diffs.length - 1;\n      switch (diff[0]) {\n        case _cleanupSemantic.DIFF_DELETE:\n          return printDeleteLine(line, isFirstOrLast, options);\n        case _cleanupSemantic.DIFF_INSERT:\n          return printInsertLine(line, isFirstOrLast, options);\n        default:\n          return printCommonLine(line, isFirstOrLast, options);\n      }\n    })\n    .join('\\n');\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL2pvaW5BbGlnbmVkRGlmZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0NBQWdDLEdBQUcsOEJBQThCO0FBQ2pFLHVCQUF1QixtQkFBTyxDQUFDLGtGQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXLEVBQUUsbURBQW1EO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXLEVBQUUsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELFdBQVc7QUFDakU7QUFDQSxXQUFXLFdBQVcsR0FBRyxlQUFlLEdBQUcsV0FBVyxHQUFHLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLElBQUk7QUFDSixrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVtby1sb2dpbi8uL25vZGVfbW9kdWxlcy9qZXN0LWRpZmYvYnVpbGQvam9pbkFsaWduZWREaWZmcy5qcz9hOGUwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmpvaW5BbGlnbmVkRGlmZnNOb0V4cGFuZCA9IGV4cG9ydHMuam9pbkFsaWduZWREaWZmc0V4cGFuZCA9IHZvaWQgMDtcbnZhciBfY2xlYW51cFNlbWFudGljID0gcmVxdWlyZSgnLi9jbGVhbnVwU2VtYW50aWMnKTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCBmb3JtYXRUcmFpbGluZ1NwYWNlcyA9IChsaW5lLCB0cmFpbGluZ1NwYWNlRm9ybWF0dGVyKSA9PlxuICBsaW5lLnJlcGxhY2UoL1xccyskLywgbWF0Y2ggPT4gdHJhaWxpbmdTcGFjZUZvcm1hdHRlcihtYXRjaCkpO1xuY29uc3QgcHJpbnREaWZmTGluZSA9IChcbiAgbGluZSxcbiAgaXNGaXJzdE9yTGFzdCxcbiAgY29sb3IsXG4gIGluZGljYXRvcixcbiAgdHJhaWxpbmdTcGFjZUZvcm1hdHRlcixcbiAgZW1wdHlGaXJzdE9yTGFzdExpbmVQbGFjZWhvbGRlclxuKSA9PlxuICBsaW5lLmxlbmd0aCAhPT0gMFxuICAgID8gY29sb3IoXG4gICAgICAgIGAke2luZGljYXRvcn0gJHtmb3JtYXRUcmFpbGluZ1NwYWNlcyhsaW5lLCB0cmFpbGluZ1NwYWNlRm9ybWF0dGVyKX1gXG4gICAgICApXG4gICAgOiBpbmRpY2F0b3IgIT09ICcgJ1xuICAgID8gY29sb3IoaW5kaWNhdG9yKVxuICAgIDogaXNGaXJzdE9yTGFzdCAmJiBlbXB0eUZpcnN0T3JMYXN0TGluZVBsYWNlaG9sZGVyLmxlbmd0aCAhPT0gMFxuICAgID8gY29sb3IoYCR7aW5kaWNhdG9yfSAke2VtcHR5Rmlyc3RPckxhc3RMaW5lUGxhY2Vob2xkZXJ9YClcbiAgICA6ICcnO1xuY29uc3QgcHJpbnREZWxldGVMaW5lID0gKFxuICBsaW5lLFxuICBpc0ZpcnN0T3JMYXN0LFxuICB7XG4gICAgYUNvbG9yLFxuICAgIGFJbmRpY2F0b3IsXG4gICAgY2hhbmdlTGluZVRyYWlsaW5nU3BhY2VDb2xvcixcbiAgICBlbXB0eUZpcnN0T3JMYXN0TGluZVBsYWNlaG9sZGVyXG4gIH1cbikgPT5cbiAgcHJpbnREaWZmTGluZShcbiAgICBsaW5lLFxuICAgIGlzRmlyc3RPckxhc3QsXG4gICAgYUNvbG9yLFxuICAgIGFJbmRpY2F0b3IsXG4gICAgY2hhbmdlTGluZVRyYWlsaW5nU3BhY2VDb2xvcixcbiAgICBlbXB0eUZpcnN0T3JMYXN0TGluZVBsYWNlaG9sZGVyXG4gICk7XG5jb25zdCBwcmludEluc2VydExpbmUgPSAoXG4gIGxpbmUsXG4gIGlzRmlyc3RPckxhc3QsXG4gIHtcbiAgICBiQ29sb3IsXG4gICAgYkluZGljYXRvcixcbiAgICBjaGFuZ2VMaW5lVHJhaWxpbmdTcGFjZUNvbG9yLFxuICAgIGVtcHR5Rmlyc3RPckxhc3RMaW5lUGxhY2Vob2xkZXJcbiAgfVxuKSA9PlxuICBwcmludERpZmZMaW5lKFxuICAgIGxpbmUsXG4gICAgaXNGaXJzdE9yTGFzdCxcbiAgICBiQ29sb3IsXG4gICAgYkluZGljYXRvcixcbiAgICBjaGFuZ2VMaW5lVHJhaWxpbmdTcGFjZUNvbG9yLFxuICAgIGVtcHR5Rmlyc3RPckxhc3RMaW5lUGxhY2Vob2xkZXJcbiAgKTtcbmNvbnN0IHByaW50Q29tbW9uTGluZSA9IChcbiAgbGluZSxcbiAgaXNGaXJzdE9yTGFzdCxcbiAge1xuICAgIGNvbW1vbkNvbG9yLFxuICAgIGNvbW1vbkluZGljYXRvcixcbiAgICBjb21tb25MaW5lVHJhaWxpbmdTcGFjZUNvbG9yLFxuICAgIGVtcHR5Rmlyc3RPckxhc3RMaW5lUGxhY2Vob2xkZXJcbiAgfVxuKSA9PlxuICBwcmludERpZmZMaW5lKFxuICAgIGxpbmUsXG4gICAgaXNGaXJzdE9yTGFzdCxcbiAgICBjb21tb25Db2xvcixcbiAgICBjb21tb25JbmRpY2F0b3IsXG4gICAgY29tbW9uTGluZVRyYWlsaW5nU3BhY2VDb2xvcixcbiAgICBlbXB0eUZpcnN0T3JMYXN0TGluZVBsYWNlaG9sZGVyXG4gICk7XG5cbi8vIEluIEdOVSBkaWZmIGZvcm1hdCwgaW5kZXhlcyBhcmUgb25lLWJhc2VkIGluc3RlYWQgb2YgemVyby1iYXNlZC5cbmNvbnN0IGNyZWF0ZVBhdGNoTWFyayA9IChhU3RhcnQsIGFFbmQsIGJTdGFydCwgYkVuZCwge3BhdGNoQ29sb3J9KSA9PlxuICBwYXRjaENvbG9yKFxuICAgIGBAQCAtJHthU3RhcnQgKyAxfSwke2FFbmQgLSBhU3RhcnR9ICske2JTdGFydCArIDF9LCR7YkVuZCAtIGJTdGFydH0gQEBgXG4gICk7XG5cbi8vIGplc3QgLS1uby1leHBhbmRcbi8vXG4vLyBHaXZlbiBhcnJheSBvZiBhbGlnbmVkIHN0cmluZ3Mgd2l0aCBpbnZlcnNlIGhpZ2hsaWdodCBmb3JtYXR0aW5nLFxuLy8gcmV0dXJuIGpvaW5lZCBsaW5lcyB3aXRoIGRpZmYgZm9ybWF0dGluZyAoYW5kIHBhdGNoIG1hcmtzLCBpZiBuZWVkZWQpLlxuY29uc3Qgam9pbkFsaWduZWREaWZmc05vRXhwYW5kID0gKGRpZmZzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGlMZW5ndGggPSBkaWZmcy5sZW5ndGg7XG4gIGNvbnN0IG5Db250ZXh0TGluZXMgPSBvcHRpb25zLmNvbnRleHRMaW5lcztcbiAgY29uc3QgbkNvbnRleHRMaW5lczIgPSBuQ29udGV4dExpbmVzICsgbkNvbnRleHRMaW5lcztcblxuICAvLyBGaXJzdCBwYXNzOiBjb3VudCBvdXRwdXQgbGluZXMgYW5kIHNlZSBpZiBpdCBoYXMgcGF0Y2hlcy5cbiAgbGV0IGpMZW5ndGggPSBpTGVuZ3RoO1xuICBsZXQgaGFzRXhjZXNzQXRTdGFydE9yRW5kID0gZmFsc2U7XG4gIGxldCBuRXhjZXNzZXNCZXR3ZWVuQ2hhbmdlcyA9IDA7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgIT09IGlMZW5ndGgpIHtcbiAgICBjb25zdCBpU3RhcnQgPSBpO1xuICAgIHdoaWxlIChpICE9PSBpTGVuZ3RoICYmIGRpZmZzW2ldWzBdID09PSBfY2xlYW51cFNlbWFudGljLkRJRkZfRVFVQUwpIHtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgaWYgKGlTdGFydCAhPT0gaSkge1xuICAgICAgaWYgKGlTdGFydCA9PT0gMCkge1xuICAgICAgICAvLyBhdCBzdGFydFxuICAgICAgICBpZiAoaSA+IG5Db250ZXh0TGluZXMpIHtcbiAgICAgICAgICBqTGVuZ3RoIC09IGkgLSBuQ29udGV4dExpbmVzOyAvLyBzdWJ0cmFjdCBleGNlc3MgY29tbW9uIGxpbmVzXG4gICAgICAgICAgaGFzRXhjZXNzQXRTdGFydE9yRW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID09PSBpTGVuZ3RoKSB7XG4gICAgICAgIC8vIGF0IGVuZFxuICAgICAgICBjb25zdCBuID0gaSAtIGlTdGFydDtcbiAgICAgICAgaWYgKG4gPiBuQ29udGV4dExpbmVzKSB7XG4gICAgICAgICAgakxlbmd0aCAtPSBuIC0gbkNvbnRleHRMaW5lczsgLy8gc3VidHJhY3QgZXhjZXNzIGNvbW1vbiBsaW5lc1xuICAgICAgICAgIGhhc0V4Y2Vzc0F0U3RhcnRPckVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJldHdlZW4gY2hhbmdlc1xuICAgICAgICBjb25zdCBuID0gaSAtIGlTdGFydDtcbiAgICAgICAgaWYgKG4gPiBuQ29udGV4dExpbmVzMikge1xuICAgICAgICAgIGpMZW5ndGggLT0gbiAtIG5Db250ZXh0TGluZXMyOyAvLyBzdWJ0cmFjdCBleGNlc3MgY29tbW9uIGxpbmVzXG4gICAgICAgICAgbkV4Y2Vzc2VzQmV0d2VlbkNoYW5nZXMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoaSAhPT0gaUxlbmd0aCAmJiBkaWZmc1tpXVswXSAhPT0gX2NsZWFudXBTZW1hbnRpYy5ESUZGX0VRVUFMKSB7XG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc1BhdGNoID0gbkV4Y2Vzc2VzQmV0d2VlbkNoYW5nZXMgIT09IDAgfHwgaGFzRXhjZXNzQXRTdGFydE9yRW5kO1xuICBpZiAobkV4Y2Vzc2VzQmV0d2VlbkNoYW5nZXMgIT09IDApIHtcbiAgICBqTGVuZ3RoICs9IG5FeGNlc3Nlc0JldHdlZW5DaGFuZ2VzICsgMTsgLy8gYWRkIHBhdGNoIGxpbmVzXG4gIH0gZWxzZSBpZiAoaGFzRXhjZXNzQXRTdGFydE9yRW5kKSB7XG4gICAgakxlbmd0aCArPSAxOyAvLyBhZGQgcGF0Y2ggbGluZVxuICB9XG5cbiAgY29uc3Qgakxhc3QgPSBqTGVuZ3RoIC0gMTtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGpQYXRjaE1hcmsgPSAwOyAvLyBpbmRleCBvZiBwbGFjZWhvbGRlciBsaW5lIGZvciBjdXJyZW50IHBhdGNoIG1hcmtcbiAgaWYgKGhhc1BhdGNoKSB7XG4gICAgbGluZXMucHVzaCgnJyk7IC8vIHBsYWNlaG9sZGVyIGxpbmUgZm9yIGZpcnN0IHBhdGNoIG1hcmtcbiAgfVxuXG4gIC8vIEluZGV4ZXMgb2YgZXhwZWN0ZWQgb3IgcmVjZWl2ZWQgbGluZXMgaW4gY3VycmVudCBwYXRjaDpcbiAgbGV0IGFTdGFydCA9IDA7XG4gIGxldCBiU3RhcnQgPSAwO1xuICBsZXQgYUVuZCA9IDA7XG4gIGxldCBiRW5kID0gMDtcbiAgY29uc3QgcHVzaENvbW1vbkxpbmUgPSBsaW5lID0+IHtcbiAgICBjb25zdCBqID0gbGluZXMubGVuZ3RoO1xuICAgIGxpbmVzLnB1c2gocHJpbnRDb21tb25MaW5lKGxpbmUsIGogPT09IDAgfHwgaiA9PT0gakxhc3QsIG9wdGlvbnMpKTtcbiAgICBhRW5kICs9IDE7XG4gICAgYkVuZCArPSAxO1xuICB9O1xuICBjb25zdCBwdXNoRGVsZXRlTGluZSA9IGxpbmUgPT4ge1xuICAgIGNvbnN0IGogPSBsaW5lcy5sZW5ndGg7XG4gICAgbGluZXMucHVzaChwcmludERlbGV0ZUxpbmUobGluZSwgaiA9PT0gMCB8fCBqID09PSBqTGFzdCwgb3B0aW9ucykpO1xuICAgIGFFbmQgKz0gMTtcbiAgfTtcbiAgY29uc3QgcHVzaEluc2VydExpbmUgPSBsaW5lID0+IHtcbiAgICBjb25zdCBqID0gbGluZXMubGVuZ3RoO1xuICAgIGxpbmVzLnB1c2gocHJpbnRJbnNlcnRMaW5lKGxpbmUsIGogPT09IDAgfHwgaiA9PT0gakxhc3QsIG9wdGlvbnMpKTtcbiAgICBiRW5kICs9IDE7XG4gIH07XG5cbiAgLy8gU2Vjb25kIHBhc3M6IHB1c2ggbGluZXMgd2l0aCBkaWZmIGZvcm1hdHRpbmcgKGFuZCBwYXRjaCBtYXJrcywgaWYgbmVlZGVkKS5cbiAgaSA9IDA7XG4gIHdoaWxlIChpICE9PSBpTGVuZ3RoKSB7XG4gICAgbGV0IGlTdGFydCA9IGk7XG4gICAgd2hpbGUgKGkgIT09IGlMZW5ndGggJiYgZGlmZnNbaV1bMF0gPT09IF9jbGVhbnVwU2VtYW50aWMuRElGRl9FUVVBTCkge1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICBpZiAoaVN0YXJ0ICE9PSBpKSB7XG4gICAgICBpZiAoaVN0YXJ0ID09PSAwKSB7XG4gICAgICAgIC8vIGF0IGJlZ2lubmluZ1xuICAgICAgICBpZiAoaSA+IG5Db250ZXh0TGluZXMpIHtcbiAgICAgICAgICBpU3RhcnQgPSBpIC0gbkNvbnRleHRMaW5lcztcbiAgICAgICAgICBhU3RhcnQgPSBpU3RhcnQ7XG4gICAgICAgICAgYlN0YXJ0ID0gaVN0YXJ0O1xuICAgICAgICAgIGFFbmQgPSBhU3RhcnQ7XG4gICAgICAgICAgYkVuZCA9IGJTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpQ29tbW9uID0gaVN0YXJ0OyBpQ29tbW9uICE9PSBpOyBpQ29tbW9uICs9IDEpIHtcbiAgICAgICAgICBwdXNoQ29tbW9uTGluZShkaWZmc1tpQ29tbW9uXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaUxlbmd0aCkge1xuICAgICAgICAvLyBhdCBlbmRcbiAgICAgICAgY29uc3QgaUVuZCA9IGkgLSBpU3RhcnQgPiBuQ29udGV4dExpbmVzID8gaVN0YXJ0ICsgbkNvbnRleHRMaW5lcyA6IGk7XG4gICAgICAgIGZvciAobGV0IGlDb21tb24gPSBpU3RhcnQ7IGlDb21tb24gIT09IGlFbmQ7IGlDb21tb24gKz0gMSkge1xuICAgICAgICAgIHB1c2hDb21tb25MaW5lKGRpZmZzW2lDb21tb25dWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmV0d2VlbiBjaGFuZ2VzXG4gICAgICAgIGNvbnN0IG5Db21tb24gPSBpIC0gaVN0YXJ0O1xuICAgICAgICBpZiAobkNvbW1vbiA+IG5Db250ZXh0TGluZXMyKSB7XG4gICAgICAgICAgY29uc3QgaUVuZCA9IGlTdGFydCArIG5Db250ZXh0TGluZXM7XG4gICAgICAgICAgZm9yIChsZXQgaUNvbW1vbiA9IGlTdGFydDsgaUNvbW1vbiAhPT0gaUVuZDsgaUNvbW1vbiArPSAxKSB7XG4gICAgICAgICAgICBwdXNoQ29tbW9uTGluZShkaWZmc1tpQ29tbW9uXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmVzW2pQYXRjaE1hcmtdID0gY3JlYXRlUGF0Y2hNYXJrKFxuICAgICAgICAgICAgYVN0YXJ0LFxuICAgICAgICAgICAgYUVuZCxcbiAgICAgICAgICAgIGJTdGFydCxcbiAgICAgICAgICAgIGJFbmQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBqUGF0Y2hNYXJrID0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIGxpbmVzLnB1c2goJycpOyAvLyBwbGFjZWhvbGRlciBsaW5lIGZvciBuZXh0IHBhdGNoIG1hcmtcblxuICAgICAgICAgIGNvbnN0IG5PbWl0ID0gbkNvbW1vbiAtIG5Db250ZXh0TGluZXMyO1xuICAgICAgICAgIGFTdGFydCA9IGFFbmQgKyBuT21pdDtcbiAgICAgICAgICBiU3RhcnQgPSBiRW5kICsgbk9taXQ7XG4gICAgICAgICAgYUVuZCA9IGFTdGFydDtcbiAgICAgICAgICBiRW5kID0gYlN0YXJ0O1xuICAgICAgICAgIGZvciAobGV0IGlDb21tb24gPSBpIC0gbkNvbnRleHRMaW5lczsgaUNvbW1vbiAhPT0gaTsgaUNvbW1vbiArPSAxKSB7XG4gICAgICAgICAgICBwdXNoQ29tbW9uTGluZShkaWZmc1tpQ29tbW9uXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGlDb21tb24gPSBpU3RhcnQ7IGlDb21tb24gIT09IGk7IGlDb21tb24gKz0gMSkge1xuICAgICAgICAgICAgcHVzaENvbW1vbkxpbmUoZGlmZnNbaUNvbW1vbl1bMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoaSAhPT0gaUxlbmd0aCAmJiBkaWZmc1tpXVswXSA9PT0gX2NsZWFudXBTZW1hbnRpYy5ESUZGX0RFTEVURSkge1xuICAgICAgcHVzaERlbGV0ZUxpbmUoZGlmZnNbaV1bMV0pO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICB3aGlsZSAoaSAhPT0gaUxlbmd0aCAmJiBkaWZmc1tpXVswXSA9PT0gX2NsZWFudXBTZW1hbnRpYy5ESUZGX0lOU0VSVCkge1xuICAgICAgcHVzaEluc2VydExpbmUoZGlmZnNbaV1bMV0pO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUGF0Y2gpIHtcbiAgICBsaW5lc1tqUGF0Y2hNYXJrXSA9IGNyZWF0ZVBhdGNoTWFyayhhU3RhcnQsIGFFbmQsIGJTdGFydCwgYkVuZCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufTtcblxuLy8gamVzdCAtLWV4cGFuZFxuLy9cbi8vIEdpdmVuIGFycmF5IG9mIGFsaWduZWQgc3RyaW5ncyB3aXRoIGludmVyc2UgaGlnaGxpZ2h0IGZvcm1hdHRpbmcsXG4vLyByZXR1cm4gam9pbmVkIGxpbmVzIHdpdGggZGlmZiBmb3JtYXR0aW5nLlxuZXhwb3J0cy5qb2luQWxpZ25lZERpZmZzTm9FeHBhbmQgPSBqb2luQWxpZ25lZERpZmZzTm9FeHBhbmQ7XG5jb25zdCBqb2luQWxpZ25lZERpZmZzRXhwYW5kID0gKGRpZmZzLCBvcHRpb25zKSA9PlxuICBkaWZmc1xuICAgIC5tYXAoKGRpZmYsIGksIGRpZmZzKSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gZGlmZlsxXTtcbiAgICAgIGNvbnN0IGlzRmlyc3RPckxhc3QgPSBpID09PSAwIHx8IGkgPT09IGRpZmZzLmxlbmd0aCAtIDE7XG4gICAgICBzd2l0Y2ggKGRpZmZbMF0pIHtcbiAgICAgICAgY2FzZSBfY2xlYW51cFNlbWFudGljLkRJRkZfREVMRVRFOlxuICAgICAgICAgIHJldHVybiBwcmludERlbGV0ZUxpbmUobGluZSwgaXNGaXJzdE9yTGFzdCwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgX2NsZWFudXBTZW1hbnRpYy5ESUZGX0lOU0VSVDpcbiAgICAgICAgICByZXR1cm4gcHJpbnRJbnNlcnRMaW5lKGxpbmUsIGlzRmlyc3RPckxhc3QsIG9wdGlvbnMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBwcmludENvbW1vbkxpbmUobGluZSwgaXNGaXJzdE9yTGFzdCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignXFxuJyk7XG5leHBvcnRzLmpvaW5BbGlnbmVkRGlmZnNFeHBhbmQgPSBqb2luQWxpZ25lZERpZmZzRXhwYW5kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/joinAlignedDiffs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/normalizeDiffOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/jest-diff/build/normalizeDiffOptions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.normalizeDiffOptions = exports.noColor = void 0;\nvar _chalk = _interopRequireDefault(__webpack_require__(/*! chalk */ \"(ssr)/./node_modules/chalk/source/index.js\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst noColor = string => string;\nexports.noColor = noColor;\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst OPTIONS_DEFAULT = {\n  aAnnotation: 'Expected',\n  aColor: _chalk.default.green,\n  aIndicator: '-',\n  bAnnotation: 'Received',\n  bColor: _chalk.default.red,\n  bIndicator: '+',\n  changeColor: _chalk.default.inverse,\n  changeLineTrailingSpaceColor: noColor,\n  commonColor: _chalk.default.dim,\n  commonIndicator: ' ',\n  commonLineTrailingSpaceColor: noColor,\n  compareKeys: undefined,\n  contextLines: DIFF_CONTEXT_DEFAULT,\n  emptyFirstOrLastLinePlaceholder: '',\n  expand: true,\n  includeChangeCounts: false,\n  omitAnnotationLines: false,\n  patchColor: _chalk.default.yellow\n};\nconst getCompareKeys = compareKeys =>\n  compareKeys && typeof compareKeys === 'function'\n    ? compareKeys\n    : OPTIONS_DEFAULT.compareKeys;\nconst getContextLines = contextLines =>\n  typeof contextLines === 'number' &&\n  Number.isSafeInteger(contextLines) &&\n  contextLines >= 0\n    ? contextLines\n    : DIFF_CONTEXT_DEFAULT;\n\n// Pure function returns options with all properties.\nconst normalizeDiffOptions = (options = {}) => ({\n  ...OPTIONS_DEFAULT,\n  ...options,\n  compareKeys: getCompareKeys(options.compareKeys),\n  contextLines: getContextLines(options.contextLines)\n});\nexports.normalizeDiffOptions = normalizeDiffOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL25vcm1hbGl6ZURpZmZPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLDRCQUE0QixHQUFHLGVBQWU7QUFDOUMsb0NBQW9DLG1CQUFPLENBQUMseURBQU87QUFDbkQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVtby1sb2dpbi8uL25vZGVfbW9kdWxlcy9qZXN0LWRpZmYvYnVpbGQvbm9ybWFsaXplRGlmZk9wdGlvbnMuanM/YzAyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemVEaWZmT3B0aW9ucyA9IGV4cG9ydHMubm9Db2xvciA9IHZvaWQgMDtcbnZhciBfY2hhbGsgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ2NoYWxrJykpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtkZWZhdWx0OiBvYmp9O1xufVxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IG5vQ29sb3IgPSBzdHJpbmcgPT4gc3RyaW5nO1xuZXhwb3J0cy5ub0NvbG9yID0gbm9Db2xvcjtcbmNvbnN0IERJRkZfQ09OVEVYVF9ERUZBVUxUID0gNTtcbmNvbnN0IE9QVElPTlNfREVGQVVMVCA9IHtcbiAgYUFubm90YXRpb246ICdFeHBlY3RlZCcsXG4gIGFDb2xvcjogX2NoYWxrLmRlZmF1bHQuZ3JlZW4sXG4gIGFJbmRpY2F0b3I6ICctJyxcbiAgYkFubm90YXRpb246ICdSZWNlaXZlZCcsXG4gIGJDb2xvcjogX2NoYWxrLmRlZmF1bHQucmVkLFxuICBiSW5kaWNhdG9yOiAnKycsXG4gIGNoYW5nZUNvbG9yOiBfY2hhbGsuZGVmYXVsdC5pbnZlcnNlLFxuICBjaGFuZ2VMaW5lVHJhaWxpbmdTcGFjZUNvbG9yOiBub0NvbG9yLFxuICBjb21tb25Db2xvcjogX2NoYWxrLmRlZmF1bHQuZGltLFxuICBjb21tb25JbmRpY2F0b3I6ICcgJyxcbiAgY29tbW9uTGluZVRyYWlsaW5nU3BhY2VDb2xvcjogbm9Db2xvcixcbiAgY29tcGFyZUtleXM6IHVuZGVmaW5lZCxcbiAgY29udGV4dExpbmVzOiBESUZGX0NPTlRFWFRfREVGQVVMVCxcbiAgZW1wdHlGaXJzdE9yTGFzdExpbmVQbGFjZWhvbGRlcjogJycsXG4gIGV4cGFuZDogdHJ1ZSxcbiAgaW5jbHVkZUNoYW5nZUNvdW50czogZmFsc2UsXG4gIG9taXRBbm5vdGF0aW9uTGluZXM6IGZhbHNlLFxuICBwYXRjaENvbG9yOiBfY2hhbGsuZGVmYXVsdC55ZWxsb3dcbn07XG5jb25zdCBnZXRDb21wYXJlS2V5cyA9IGNvbXBhcmVLZXlzID0+XG4gIGNvbXBhcmVLZXlzICYmIHR5cGVvZiBjb21wYXJlS2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY29tcGFyZUtleXNcbiAgICA6IE9QVElPTlNfREVGQVVMVC5jb21wYXJlS2V5cztcbmNvbnN0IGdldENvbnRleHRMaW5lcyA9IGNvbnRleHRMaW5lcyA9PlxuICB0eXBlb2YgY29udGV4dExpbmVzID09PSAnbnVtYmVyJyAmJlxuICBOdW1iZXIuaXNTYWZlSW50ZWdlcihjb250ZXh0TGluZXMpICYmXG4gIGNvbnRleHRMaW5lcyA+PSAwXG4gICAgPyBjb250ZXh0TGluZXNcbiAgICA6IERJRkZfQ09OVEVYVF9ERUZBVUxUO1xuXG4vLyBQdXJlIGZ1bmN0aW9uIHJldHVybnMgb3B0aW9ucyB3aXRoIGFsbCBwcm9wZXJ0aWVzLlxuY29uc3Qgbm9ybWFsaXplRGlmZk9wdGlvbnMgPSAob3B0aW9ucyA9IHt9KSA9PiAoe1xuICAuLi5PUFRJT05TX0RFRkFVTFQsXG4gIC4uLm9wdGlvbnMsXG4gIGNvbXBhcmVLZXlzOiBnZXRDb21wYXJlS2V5cyhvcHRpb25zLmNvbXBhcmVLZXlzKSxcbiAgY29udGV4dExpbmVzOiBnZXRDb250ZXh0TGluZXMob3B0aW9ucy5jb250ZXh0TGluZXMpXG59KTtcbmV4cG9ydHMubm9ybWFsaXplRGlmZk9wdGlvbnMgPSBub3JtYWxpemVEaWZmT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/normalizeDiffOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jest-diff/build/printDiffs.js":
/*!****************************************************!*\
  !*** ./node_modules/jest-diff/build/printDiffs.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.diffStringsUnified = exports.diffStringsRaw = void 0;\nvar _cleanupSemantic = __webpack_require__(/*! ./cleanupSemantic */ \"(ssr)/./node_modules/jest-diff/build/cleanupSemantic.js\");\nvar _diffLines = __webpack_require__(/*! ./diffLines */ \"(ssr)/./node_modules/jest-diff/build/diffLines.js\");\nvar _diffStrings = _interopRequireDefault(__webpack_require__(/*! ./diffStrings */ \"(ssr)/./node_modules/jest-diff/build/diffStrings.js\"));\nvar _getAlignedDiffs = _interopRequireDefault(__webpack_require__(/*! ./getAlignedDiffs */ \"(ssr)/./node_modules/jest-diff/build/getAlignedDiffs.js\"));\nvar _normalizeDiffOptions = __webpack_require__(/*! ./normalizeDiffOptions */ \"(ssr)/./node_modules/jest-diff/build/normalizeDiffOptions.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) =>\n        diff[0] === _cleanupSemantic.DIFF_EQUAL &&\n        (i !== iLast || diff[1] !== '\\n')\n    );\n  }\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n};\n\n// Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n');\n\n    // getAlignedDiffs assumes that a newline was appended to the strings.\n    const diffs = diffStringsRaw(\n      isMultiline ? `${a}\\n` : a,\n      isMultiline ? `${b}\\n` : b,\n      true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(\n        options\n      );\n      const lines = (0, _getAlignedDiffs.default)(\n        diffs,\n        optionsNormalized.changeColor\n      );\n      return (0, _diffLines.printDiffLines)(lines, optionsNormalized);\n    }\n  }\n\n  // Fall back to line-by-line diff.\n  return (0, _diffLines.diffLinesUnified)(\n    a.split('\\n'),\n    b.split('\\n'),\n    options\n  );\n};\n\n// Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\nexports.diffStringsUnified = diffStringsUnified;\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\nexports.diffStringsRaw = diffStringsRaw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL3ByaW50RGlmZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCLEdBQUcsc0JBQXNCO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLGtGQUFtQjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBYTtBQUN0QywwQ0FBMEMsbUJBQU8sQ0FBQywwRUFBZTtBQUNqRSw4Q0FBOEMsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDekUsNEJBQTRCLG1CQUFPLENBQUMsNEZBQXdCO0FBQzVEO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2RlbW8tbG9naW4vLi9ub2RlX21vZHVsZXMvamVzdC1kaWZmL2J1aWxkL3ByaW50RGlmZnMuanM/MGUzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kaWZmU3RyaW5nc1VuaWZpZWQgPSBleHBvcnRzLmRpZmZTdHJpbmdzUmF3ID0gdm9pZCAwO1xudmFyIF9jbGVhbnVwU2VtYW50aWMgPSByZXF1aXJlKCcuL2NsZWFudXBTZW1hbnRpYycpO1xudmFyIF9kaWZmTGluZXMgPSByZXF1aXJlKCcuL2RpZmZMaW5lcycpO1xudmFyIF9kaWZmU3RyaW5ncyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnLi9kaWZmU3RyaW5ncycpKTtcbnZhciBfZ2V0QWxpZ25lZERpZmZzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCcuL2dldEFsaWduZWREaWZmcycpKTtcbnZhciBfbm9ybWFsaXplRGlmZk9wdGlvbnMgPSByZXF1aXJlKCcuL25vcm1hbGl6ZURpZmZPcHRpb25zJyk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge2RlZmF1bHQ6IG9ian07XG59XG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3QgaGFzQ29tbW9uRGlmZiA9IChkaWZmcywgaXNNdWx0aWxpbmUpID0+IHtcbiAgaWYgKGlzTXVsdGlsaW5lKSB7XG4gICAgLy8gSW1wb3J0YW50OiBJZ25vcmUgY29tbW9uIG5ld2xpbmUgdGhhdCB3YXMgYXBwZW5kZWQgdG8gbXVsdGlsaW5lIHN0cmluZ3MhXG4gICAgY29uc3QgaUxhc3QgPSBkaWZmcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBkaWZmcy5zb21lKFxuICAgICAgKGRpZmYsIGkpID0+XG4gICAgICAgIGRpZmZbMF0gPT09IF9jbGVhbnVwU2VtYW50aWMuRElGRl9FUVVBTCAmJlxuICAgICAgICAoaSAhPT0gaUxhc3QgfHwgZGlmZlsxXSAhPT0gJ1xcbicpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGlmZnMuc29tZShkaWZmID0+IGRpZmZbMF0gPT09IF9jbGVhbnVwU2VtYW50aWMuRElGRl9FUVVBTCk7XG59O1xuXG4vLyBDb21wYXJlIHR3byBzdHJpbmdzIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXG4vLyBGb3JtYXQgYXMgY29tcGFyaXNvbiBsaW5lcyBpbiB3aGljaCBjaGFuZ2VkIHN1YnN0cmluZ3MgaGF2ZSBpbnZlcnNlIGNvbG9ycy5cbmNvbnN0IGRpZmZTdHJpbmdzVW5pZmllZCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmIChhICE9PSBiICYmIGEubGVuZ3RoICE9PSAwICYmIGIubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgaXNNdWx0aWxpbmUgPSBhLmluY2x1ZGVzKCdcXG4nKSB8fCBiLmluY2x1ZGVzKCdcXG4nKTtcblxuICAgIC8vIGdldEFsaWduZWREaWZmcyBhc3N1bWVzIHRoYXQgYSBuZXdsaW5lIHdhcyBhcHBlbmRlZCB0byB0aGUgc3RyaW5ncy5cbiAgICBjb25zdCBkaWZmcyA9IGRpZmZTdHJpbmdzUmF3KFxuICAgICAgaXNNdWx0aWxpbmUgPyBgJHthfVxcbmAgOiBhLFxuICAgICAgaXNNdWx0aWxpbmUgPyBgJHtifVxcbmAgOiBiLFxuICAgICAgdHJ1ZSAvLyBjbGVhbnVwU2VtYW50aWNcbiAgICApO1xuXG4gICAgaWYgKGhhc0NvbW1vbkRpZmYoZGlmZnMsIGlzTXVsdGlsaW5lKSkge1xuICAgICAgY29uc3Qgb3B0aW9uc05vcm1hbGl6ZWQgPSAoMCwgX25vcm1hbGl6ZURpZmZPcHRpb25zLm5vcm1hbGl6ZURpZmZPcHRpb25zKShcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gKDAsIF9nZXRBbGlnbmVkRGlmZnMuZGVmYXVsdCkoXG4gICAgICAgIGRpZmZzLFxuICAgICAgICBvcHRpb25zTm9ybWFsaXplZC5jaGFuZ2VDb2xvclxuICAgICAgKTtcbiAgICAgIHJldHVybiAoMCwgX2RpZmZMaW5lcy5wcmludERpZmZMaW5lcykobGluZXMsIG9wdGlvbnNOb3JtYWxpemVkKTtcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gbGluZS1ieS1saW5lIGRpZmYuXG4gIHJldHVybiAoMCwgX2RpZmZMaW5lcy5kaWZmTGluZXNVbmlmaWVkKShcbiAgICBhLnNwbGl0KCdcXG4nKSxcbiAgICBiLnNwbGl0KCdcXG4nKSxcbiAgICBvcHRpb25zXG4gICk7XG59O1xuXG4vLyBDb21wYXJlIHR3byBzdHJpbmdzIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXG4vLyBPcHRpb25hbGx5IGNsZWFuIHVwIHNtYWxsIGNvbW1vbiBzdWJzdHJpbmdzLCBhbHNvIGtub3duIGFzIGNoYWZmLlxuZXhwb3J0cy5kaWZmU3RyaW5nc1VuaWZpZWQgPSBkaWZmU3RyaW5nc1VuaWZpZWQ7XG5jb25zdCBkaWZmU3RyaW5nc1JhdyA9IChhLCBiLCBjbGVhbnVwKSA9PiB7XG4gIGNvbnN0IGRpZmZzID0gKDAsIF9kaWZmU3RyaW5ncy5kZWZhdWx0KShhLCBiKTtcbiAgaWYgKGNsZWFudXApIHtcbiAgICAoMCwgX2NsZWFudXBTZW1hbnRpYy5jbGVhbnVwU2VtYW50aWMpKGRpZmZzKTsgLy8gaW1wdXJlIGZ1bmN0aW9uXG4gIH1cblxuICByZXR1cm4gZGlmZnM7XG59O1xuZXhwb3J0cy5kaWZmU3RyaW5nc1JhdyA9IGRpZmZTdHJpbmdzUmF3O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jest-diff/build/printDiffs.js\n");

/***/ })

};
;