"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/diff-sequences";
exports.ids = ["vendor-chunks/diff-sequences"];
exports.modules = {

/***/ "(ssr)/./node_modules/diff-sequences/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/diff-sequences/build/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = diffSequence;\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals insersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n\n// Input callback function compares items at indexes in the sequences.\n\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\n// Either original functions or wrapped to swap indexes if graph is transposed.\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\nconst pkg = 'diff-sequences'; // for error messages\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\nconst countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {\n  let nCommon = 0;\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n  return nCommon;\n};\n\n// Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\nconst countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {\n  let nCommon = 0;\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n  return nCommon;\n};\n\n// A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\nconst extendPathsF = (\n  d,\n  aEnd,\n  bEnd,\n  bF,\n  isCommon,\n  aIndexesF,\n  iMaxF // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n  aIndexesF[iF] += countCommonItemsF(\n    aFirst + 1,\n    aEnd,\n    bF + aFirst - kF + 1,\n    bEnd,\n    isCommon\n  );\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nF = d < iMaxF ? d : iMaxF;\n\n  // The diagonals kF are odd when d is odd and even when d is even.\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    }\n\n    // To get last point of path segment, move along diagonal of common items.\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] =\n      aFirst +\n      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n  return iMaxF;\n};\n\n// A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\nconst extendPathsR = (\n  d,\n  aStart,\n  bStart,\n  bR,\n  isCommon,\n  aIndexesR,\n  iMaxR // return the value because optimization might decrease it\n) => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n  aIndexesR[iR] -= countCommonItemsR(\n    aStart,\n    aFirst - 1,\n    bStart,\n    bR + aFirst - kR - 1,\n    isCommon\n  );\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nR = d < iMaxR ? d : iMaxR;\n\n  // The diagonals kR are odd when d is odd and even when d is even.\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    }\n\n    // To get last point of path segment, move along diagonal of common items.\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] =\n      aFirst -\n      countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon\n      );\n  }\n  return iMaxR;\n};\n\n// A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\nconst extendOverlappablePathsF = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division // update prop values if return true\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n\n  // Range of diagonals in which forward and reverse paths might overlap.\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nF = d < iMaxF ? d : iMaxF;\n\n  // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev + 1; // horizontal to delete from a\n\n    // To get last point of path segment, move along diagonal of common items.\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bFirst + 1,\n      bEnd,\n      isCommon\n    );\n    const aLast = aFirst + nCommonF;\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n\n      // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n\n        // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n        const nCommonR = countCommonItemsR(\n          aStart,\n          aLastPrev,\n          bStart,\n          bLastPrev,\n          isCommon\n        );\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n        division.nChangePreceding = d - 1;\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n        division.nCommonFollowing = nCommonF;\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n        division.nChangeFollowing = d - 1;\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\nconst extendOverlappablePathsR = (\n  d,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  iMaxF,\n  aIndexesR,\n  iMaxR,\n  division // update prop values if return true\n) => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n\n  // Range of diagonals in which forward and reverse paths might overlap.\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nR = d < iMaxR ? d : iMaxR;\n\n  // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev - 1; // horizontal to delete from a\n\n    // To get last point of path segment, move along diagonal of common items.\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bFirst - 1,\n      isCommon\n    );\n    const aLast = aFirst - nCommonR;\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2;\n\n      // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n        division.nChangePreceding = d;\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n        division.nChangeFollowing = d - 1;\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n\n          // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n          const nCommonF = countCommonItemsF(\n            aLastPrev,\n            aEnd,\n            bLastPrev,\n            bEnd,\n            isCommon\n          );\n          division.nCommonFollowing = nCommonF;\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\nconst divide = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  isCommon,\n  aIndexesF,\n  aIndexesR,\n  division // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n\n  // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n  const baDeltaLength = bLength - aLength;\n\n  // Optimization: max diagonal in graph intersects corner of shorter side.\n  let iMaxF = aLength;\n  let iMaxR = aLength;\n\n  // Initialize no changes yet in forward or reverse direction:\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if (\n        // If a reverse path overlaps a forward path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsR(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2;\n\n    // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(\n        d - 1,\n        aStart,\n        bStart,\n        bR,\n        isCommon,\n        aIndexesR,\n        iMaxR\n      );\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if (\n        // If a forward path overlaps a reverse path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsF(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division\n        )\n      ) {\n        return;\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error(\n    `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`\n  );\n};\n\n// Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\nconst findSubsequences = (\n  nChange,\n  aStart,\n  aEnd,\n  bStart,\n  bEnd,\n  transposed,\n  callbacks,\n  aIndexesF,\n  aIndexesR,\n  division // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const {foundSubsequence, isCommon} = callbacks[0];\n      callbacks[1] = {\n        foundSubsequence: (nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        },\n        isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex)\n      };\n    }\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n  const {foundSubsequence, isCommon} = callbacks[transposed ? 1 : 0];\n\n  // Divide the index intervals at the middle change.\n  divide(\n    nChange,\n    aStart,\n    aEnd,\n    bStart,\n    bEnd,\n    isCommon,\n    aIndexesF,\n    aIndexesR,\n    division\n  );\n  const {\n    nChangePreceding,\n    aEndPreceding,\n    bEndPreceding,\n    nCommonPreceding,\n    aCommonPreceding,\n    bCommonPreceding,\n    nCommonFollowing,\n    aCommonFollowing,\n    bCommonFollowing,\n    nChangeFollowing,\n    aStartFollowing,\n    bStartFollowing\n  } = division;\n\n  // Unless either index interval is empty, they might contain common items.\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(\n      nChangePreceding,\n      aStart,\n      aEndPreceding,\n      bStart,\n      bEndPreceding,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  }\n\n  // Return common subsequences that are adjacent to the middle change.\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  }\n\n  // Unless either index interval is empty, they might contain common items.\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(\n      nChangeFollowing,\n      aStartFollowing,\n      aEnd,\n      bStartFollowing,\n      bEnd,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division\n    );\n  }\n};\nconst validateLength = (name, arg) => {\n  if (typeof arg !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n  }\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\nconst validateCallback = (name, arg) => {\n  const type = typeof arg;\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n};\n\n// Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\nfunction diffSequence(aLength, bLength, isCommon, foundSubsequence) {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence);\n\n  // Count common items from the start in the forward direction.\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  }\n\n  // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF;\n\n    // Count common items from the end in the reverse direction.\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aLength - 1,\n      bStart,\n      bLength - 1,\n      isCommon\n    );\n\n    // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR;\n\n    // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n    const nCommonFR = nCommonF + nCommonR;\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n      const transposed = false; // call the original unwrapped functions\n      const callbacks = [\n        {\n          foundSubsequence,\n          isCommon\n        }\n      ];\n\n      // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n      const aIndexesF = [NOT_YET_SET];\n      // from the end at bottom right in the reverse direction:\n      const aIndexesR = [NOT_YET_SET];\n\n      // Initialize one object as output of all calls to divide function.\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET\n      };\n\n      // Find and return common subsequences in the trimmed index intervals.\n      findSubsequences(\n        nChange,\n        aStart,\n        aEnd,\n        bStart,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division\n      );\n    }\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGlmZi1zZXF1ZW5jZXMvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLE1BQU07QUFDTixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Z2luLy4vbm9kZV9tb2R1bGVzL2RpZmYtc2VxdWVuY2VzL2J1aWxkL2luZGV4LmpzPzJmOWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRpZmZTZXF1ZW5jZTtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gVGhpcyBkaWZmLXNlcXVlbmNlcyBwYWNrYWdlIGltcGxlbWVudHMgdGhlIGxpbmVhciBzcGFjZSB2YXJpYXRpb24gaW5cbi8vIEFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBJdHMgVmFyaWF0aW9ucyBieSBFdWdlbmUgVy4gTXllcnNcblxuLy8gUmVsYXRpb25zaGlwIGluIG5vdGF0aW9uIGJldHdlZW4gTXllcnMgcGFwZXIgYW5kIHRoaXMgcGFja2FnZTpcbi8vIEEgaXMgYVxuLy8gTiBpcyBhTGVuZ3RoLCBhRW5kIC0gYVN0YXJ0LCBhbmQgc28gb25cbi8vIHggaXMgYUluZGV4LCBhRmlyc3QsIGFMYXN0LCBhbmQgc28gb25cbi8vIEIgaXMgYlxuLy8gTSBpcyBiTGVuZ3RoLCBiRW5kIC0gYlN0YXJ0LCBhbmQgc28gb25cbi8vIHkgaXMgYkluZGV4LCBiRmlyc3QsIGJMYXN0LCBhbmQgc28gb25cbi8vIM6UID0gTiAtIE0gaXMgbmVnYXRpdmUgb2YgYmFEZWx0YUxlbmd0aCA9IGJMZW5ndGggLSBhTGVuZ3RoXG4vLyBEIGlzIGRcbi8vIGsgaXMga0Zcbi8vIGsgKyDOlCBpcyBrRiA9IGtSIC0gYmFEZWx0YUxlbmd0aFxuLy8gViBpcyBhSW5kZXhlc0Ygb3IgYUluZGV4ZXNSIChzZWUgY29tbWVudCBiZWxvdyBhYm91dCBJbmRleGVzIHR5cGUpXG4vLyBpbmRleCBpbnRlcnZhbHMgWzEsIE5dIGFuZCBbMSwgTV0gYXJlIFswLCBhTGVuZ3RoKSBhbmQgWzAsIGJMZW5ndGgpXG4vLyBzdGFydGluZyBwb2ludCBpbiBmb3J3YXJkIGRpcmVjdGlvbiAoMCwgMCkgaXMgKC0xLCAtMSlcbi8vIHN0YXJ0aW5nIHBvaW50IGluIHJldmVyc2UgZGlyZWN0aW9uIChOICsgMSwgTSArIDEpIGlzIChhTGVuZ3RoLCBiTGVuZ3RoKVxuXG4vLyBUaGUg4oCcZWRpdCBncmFwaOKAnSBmb3Igc2VxdWVuY2VzIGEgYW5kIGIgY29ycmVzcG9uZHMgdG8gaXRlbXM6XG4vLyBpbiBhIG9uIHRoZSBob3Jpem9udGFsIGF4aXNcbi8vIGluIGIgb24gdGhlIHZlcnRpY2FsIGF4aXNcbi8vXG4vLyBHaXZlbiBhLWNvb3JkaW5hdGUgb2YgYSBwb2ludCBpbiBhIGRpYWdvbmFsLCB5b3UgY2FuIGNvbXB1dGUgYi1jb29yZGluYXRlLlxuLy9cbi8vIEZvcndhcmQgZGlhZ29uYWxzIGtGOlxuLy8gemVybyBkaWFnb25hbCBpbnRlcnNlY3RzIHRvcCBsZWZ0IGNvcm5lclxuLy8gcG9zaXRpdmUgZGlhZ29uYWxzIGludGVyc2VjdCB0b3AgZWRnZVxuLy8gbmVnYXRpdmUgZGlhZ29uYWxzIGluc2Vyc2VjdCBsZWZ0IGVkZ2Vcbi8vXG4vLyBSZXZlcnNlIGRpYWdvbmFscyBrUjpcbi8vIHplcm8gZGlhZ29uYWwgaW50ZXJzZWN0cyBib3R0b20gcmlnaHQgY29ybmVyXG4vLyBwb3NpdGl2ZSBkaWFnb25hbHMgaW50ZXJzZWN0IHJpZ2h0IGVkZ2Vcbi8vIG5lZ2F0aXZlIGRpYWdvbmFscyBpbnRlcnNlY3QgYm90dG9tIGVkZ2VcblxuLy8gVGhlIGdyYXBoIGNvbnRhaW5zIGEgZGlyZWN0ZWQgYWN5Y2xpYyBncmFwaCBvZiBlZGdlczpcbi8vIGhvcml6b250YWw6IGRlbGV0ZSBhbiBpdGVtIGZyb20gYVxuLy8gdmVydGljYWw6IGluc2VydCBhbiBpdGVtIGZyb20gYlxuLy8gZGlhZ29uYWw6IGNvbW1vbiBpdGVtIGluIGEgYW5kIGJcbi8vXG4vLyBUaGUgYWxnb3JpdGhtIHNvbHZlcyBkdWFsIHByb2JsZW1zIGluIHRoZSBncmFwaCBhbmFsb2d5OlxuLy8gRmluZCBsb25nZXN0IGNvbW1vbiBzdWJzZXF1ZW5jZTogcGF0aCB3aXRoIG1heGltdW0gbnVtYmVyIG9mIGRpYWdvbmFsIGVkZ2VzXG4vLyBGaW5kIHNob3J0ZXN0IGVkaXQgc2NyaXB0OiBwYXRoIHdpdGggbWluaW11bSBudW1iZXIgb2Ygbm9uLWRpYWdvbmFsIGVkZ2VzXG5cbi8vIElucHV0IGNhbGxiYWNrIGZ1bmN0aW9uIGNvbXBhcmVzIGl0ZW1zIGF0IGluZGV4ZXMgaW4gdGhlIHNlcXVlbmNlcy5cblxuLy8gT3V0cHV0IGNhbGxiYWNrIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBudW1iZXIgb2YgYWRqYWNlbnQgaXRlbXNcbi8vIGFuZCBzdGFydGluZyBpbmRleGVzIG9mIGVhY2ggY29tbW9uIHN1YnNlcXVlbmNlLlxuLy8gRWl0aGVyIG9yaWdpbmFsIGZ1bmN0aW9ucyBvciB3cmFwcGVkIHRvIHN3YXAgaW5kZXhlcyBpZiBncmFwaCBpcyB0cmFuc3Bvc2VkLlxuLy8gSW5kZXhlcyBpbiBzZXF1ZW5jZSBhIG9mIGxhc3QgcG9pbnQgb2YgZm9yd2FyZCBvciByZXZlcnNlIHBhdGhzIGluIGdyYXBoLlxuLy8gTXllcnMgYWxnb3JpdGhtIGluZGV4ZXMgYnkgZGlhZ29uYWwgayB3aGljaCBmb3IgbmVnYXRpdmUgaXMgYmFkIGRlb3B0IGluIFY4LlxuLy8gVGhpcyBwYWNrYWdlIGluZGV4ZXMgYnkgaUYgYW5kIGlSIHdoaWNoIGFyZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbi8vIGFuZCBhbHNvIHVwZGF0ZXMgdGhlIGluZGV4IGFycmF5cyBpbiBwbGFjZSB0byBjdXQgbWVtb3J5IGluIGhhbGYuXG4vLyBrRiA9IDIgKiBpRiAtIGRcbi8vIGtSID0gZCAtIDIgKiBpUlxuLy8gRGl2aXNpb24gb2YgaW5kZXggaW50ZXJ2YWxzIGluIHNlcXVlbmNlcyBhIGFuZCBiIGF0IHRoZSBtaWRkbGUgY2hhbmdlLlxuLy8gSW52YXJpYW50OiBpbnRlcnZhbHMgZG8gbm90IGhhdmUgY29tbW9uIGl0ZW1zIGF0IHRoZSBzdGFydCBvciBlbmQuXG5jb25zdCBwa2cgPSAnZGlmZi1zZXF1ZW5jZXMnOyAvLyBmb3IgZXJyb3IgbWVzc2FnZXNcbmNvbnN0IE5PVF9ZRVRfU0VUID0gMDsgLy8gc21hbGwgaW50IGluc3RlYWQgb2YgdW5kZWZpbmVkIHRvIGF2b2lkIGRlb3B0IGluIFY4XG5cbi8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGNvbW1vbiBpdGVtcyB0aGF0IGZvbGxvdyBpbiBmb3J3YXJkIGRpcmVjdGlvbi5cbi8vIFRoZSBsZW5ndGggb2Ygd2hhdCBNeWVycyBwYXBlciBjYWxscyBhIOKAnHNuYWtl4oCdIGluIGEgZm9yd2FyZCBwYXRoLlxuY29uc3QgY291bnRDb21tb25JdGVtc0YgPSAoYUluZGV4LCBhRW5kLCBiSW5kZXgsIGJFbmQsIGlzQ29tbW9uKSA9PiB7XG4gIGxldCBuQ29tbW9uID0gMDtcbiAgd2hpbGUgKGFJbmRleCA8IGFFbmQgJiYgYkluZGV4IDwgYkVuZCAmJiBpc0NvbW1vbihhSW5kZXgsIGJJbmRleCkpIHtcbiAgICBhSW5kZXggKz0gMTtcbiAgICBiSW5kZXggKz0gMTtcbiAgICBuQ29tbW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIG5Db21tb247XG59O1xuXG4vLyBSZXR1cm4gdGhlIG51bWJlciBvZiBjb21tb24gaXRlbXMgdGhhdCBwcmVjZWRlIGluIHJldmVyc2UgZGlyZWN0aW9uLlxuLy8gVGhlIGxlbmd0aCBvZiB3aGF0IE15ZXJzIHBhcGVyIGNhbGxzIGEg4oCcc25ha2XigJ0gaW4gYSByZXZlcnNlIHBhdGguXG5jb25zdCBjb3VudENvbW1vbkl0ZW1zUiA9IChhU3RhcnQsIGFJbmRleCwgYlN0YXJ0LCBiSW5kZXgsIGlzQ29tbW9uKSA9PiB7XG4gIGxldCBuQ29tbW9uID0gMDtcbiAgd2hpbGUgKGFTdGFydCA8PSBhSW5kZXggJiYgYlN0YXJ0IDw9IGJJbmRleCAmJiBpc0NvbW1vbihhSW5kZXgsIGJJbmRleCkpIHtcbiAgICBhSW5kZXggLT0gMTtcbiAgICBiSW5kZXggLT0gMTtcbiAgICBuQ29tbW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIG5Db21tb247XG59O1xuXG4vLyBBIHNpbXBsZSBmdW5jdGlvbiB0byBleHRlbmQgZm9yd2FyZCBwYXRocyBmcm9tIChkIC0gMSkgdG8gZCBjaGFuZ2VzXG4vLyB3aGVuIGZvcndhcmQgYW5kIHJldmVyc2UgcGF0aHMgY2Fubm90IHlldCBvdmVybGFwLlxuY29uc3QgZXh0ZW5kUGF0aHNGID0gKFxuICBkLFxuICBhRW5kLFxuICBiRW5kLFxuICBiRixcbiAgaXNDb21tb24sXG4gIGFJbmRleGVzRixcbiAgaU1heEYgLy8gcmV0dXJuIHRoZSB2YWx1ZSBiZWNhdXNlIG9wdGltaXphdGlvbiBtaWdodCBkZWNyZWFzZSBpdFxuKSA9PiB7XG4gIC8vIFVucm9sbCB0aGUgZmlyc3QgaXRlcmF0aW9uLlxuICBsZXQgaUYgPSAwO1xuICBsZXQga0YgPSAtZDsgLy8ga0YgPSAyICogaUYgLSBkXG4gIGxldCBhRmlyc3QgPSBhSW5kZXhlc0ZbaUZdOyAvLyBpbiBmaXJzdCBpdGVyYXRpb24gYWx3YXlzIGluc2VydFxuICBsZXQgYUluZGV4UHJldjEgPSBhRmlyc3Q7IC8vIHByZXYgdmFsdWUgb2YgW2lGIC0gMV0gaW4gbmV4dCBpdGVyYXRpb25cbiAgYUluZGV4ZXNGW2lGXSArPSBjb3VudENvbW1vbkl0ZW1zRihcbiAgICBhRmlyc3QgKyAxLFxuICAgIGFFbmQsXG4gICAgYkYgKyBhRmlyc3QgLSBrRiArIDEsXG4gICAgYkVuZCxcbiAgICBpc0NvbW1vblxuICApO1xuXG4gIC8vIE9wdGltaXphdGlvbjogc2tpcCBkaWFnb25hbHMgaW4gd2hpY2ggcGF0aHMgY2Fubm90IGV2ZXIgb3ZlcmxhcC5cbiAgY29uc3QgbkYgPSBkIDwgaU1heEYgPyBkIDogaU1heEY7XG5cbiAgLy8gVGhlIGRpYWdvbmFscyBrRiBhcmUgb2RkIHdoZW4gZCBpcyBvZGQgYW5kIGV2ZW4gd2hlbiBkIGlzIGV2ZW4uXG4gIGZvciAoaUYgKz0gMSwga0YgKz0gMjsgaUYgPD0gbkY7IGlGICs9IDEsIGtGICs9IDIpIHtcbiAgICAvLyBUbyBnZXQgZmlyc3QgcG9pbnQgb2YgcGF0aCBzZWdtZW50LCBtb3ZlIG9uZSBjaGFuZ2UgaW4gZm9yd2FyZCBkaXJlY3Rpb25cbiAgICAvLyBmcm9tIGxhc3QgcG9pbnQgb2YgcHJldmlvdXMgcGF0aCBzZWdtZW50IGluIGFuIGFkamFjZW50IGRpYWdvbmFsLlxuICAgIC8vIEluIGxhc3QgcG9zc2libGUgaXRlcmF0aW9uIHdoZW4gaUYgPT09IGQgYW5kIGtGID09PSBkIGFsd2F5cyBkZWxldGUuXG4gICAgaWYgKGlGICE9PSBkICYmIGFJbmRleFByZXYxIDwgYUluZGV4ZXNGW2lGXSkge1xuICAgICAgYUZpcnN0ID0gYUluZGV4ZXNGW2lGXTsgLy8gdmVydGljYWwgdG8gaW5zZXJ0IGZyb20gYlxuICAgIH0gZWxzZSB7XG4gICAgICBhRmlyc3QgPSBhSW5kZXhQcmV2MSArIDE7IC8vIGhvcml6b250YWwgdG8gZGVsZXRlIGZyb20gYVxuXG4gICAgICBpZiAoYUVuZCA8PSBhRmlyc3QpIHtcbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBkZWxldGUgbW92ZWQgcGFzdCByaWdodCBvZiBncmFwaC5cbiAgICAgICAgcmV0dXJuIGlGIC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUbyBnZXQgbGFzdCBwb2ludCBvZiBwYXRoIHNlZ21lbnQsIG1vdmUgYWxvbmcgZGlhZ29uYWwgb2YgY29tbW9uIGl0ZW1zLlxuICAgIGFJbmRleFByZXYxID0gYUluZGV4ZXNGW2lGXTtcbiAgICBhSW5kZXhlc0ZbaUZdID1cbiAgICAgIGFGaXJzdCArXG4gICAgICBjb3VudENvbW1vbkl0ZW1zRihhRmlyc3QgKyAxLCBhRW5kLCBiRiArIGFGaXJzdCAtIGtGICsgMSwgYkVuZCwgaXNDb21tb24pO1xuICB9XG4gIHJldHVybiBpTWF4Rjtcbn07XG5cbi8vIEEgc2ltcGxlIGZ1bmN0aW9uIHRvIGV4dGVuZCByZXZlcnNlIHBhdGhzIGZyb20gKGQgLSAxKSB0byBkIGNoYW5nZXNcbi8vIHdoZW4gcmV2ZXJzZSBhbmQgZm9yd2FyZCBwYXRocyBjYW5ub3QgeWV0IG92ZXJsYXAuXG5jb25zdCBleHRlbmRQYXRoc1IgPSAoXG4gIGQsXG4gIGFTdGFydCxcbiAgYlN0YXJ0LFxuICBiUixcbiAgaXNDb21tb24sXG4gIGFJbmRleGVzUixcbiAgaU1heFIgLy8gcmV0dXJuIHRoZSB2YWx1ZSBiZWNhdXNlIG9wdGltaXphdGlvbiBtaWdodCBkZWNyZWFzZSBpdFxuKSA9PiB7XG4gIC8vIFVucm9sbCB0aGUgZmlyc3QgaXRlcmF0aW9uLlxuICBsZXQgaVIgPSAwO1xuICBsZXQga1IgPSBkOyAvLyBrUiA9IGQgLSAyICogaVJcbiAgbGV0IGFGaXJzdCA9IGFJbmRleGVzUltpUl07IC8vIGluIGZpcnN0IGl0ZXJhdGlvbiBhbHdheXMgaW5zZXJ0XG4gIGxldCBhSW5kZXhQcmV2MSA9IGFGaXJzdDsgLy8gcHJldiB2YWx1ZSBvZiBbaVIgLSAxXSBpbiBuZXh0IGl0ZXJhdGlvblxuICBhSW5kZXhlc1JbaVJdIC09IGNvdW50Q29tbW9uSXRlbXNSKFxuICAgIGFTdGFydCxcbiAgICBhRmlyc3QgLSAxLFxuICAgIGJTdGFydCxcbiAgICBiUiArIGFGaXJzdCAtIGtSIC0gMSxcbiAgICBpc0NvbW1vblxuICApO1xuXG4gIC8vIE9wdGltaXphdGlvbjogc2tpcCBkaWFnb25hbHMgaW4gd2hpY2ggcGF0aHMgY2Fubm90IGV2ZXIgb3ZlcmxhcC5cbiAgY29uc3QgblIgPSBkIDwgaU1heFIgPyBkIDogaU1heFI7XG5cbiAgLy8gVGhlIGRpYWdvbmFscyBrUiBhcmUgb2RkIHdoZW4gZCBpcyBvZGQgYW5kIGV2ZW4gd2hlbiBkIGlzIGV2ZW4uXG4gIGZvciAoaVIgKz0gMSwga1IgLT0gMjsgaVIgPD0gblI7IGlSICs9IDEsIGtSIC09IDIpIHtcbiAgICAvLyBUbyBnZXQgZmlyc3QgcG9pbnQgb2YgcGF0aCBzZWdtZW50LCBtb3ZlIG9uZSBjaGFuZ2UgaW4gcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAvLyBmcm9tIGxhc3QgcG9pbnQgb2YgcHJldmlvdXMgcGF0aCBzZWdtZW50IGluIGFuIGFkamFjZW50IGRpYWdvbmFsLlxuICAgIC8vIEluIGxhc3QgcG9zc2libGUgaXRlcmF0aW9uIHdoZW4gaVIgPT09IGQgYW5kIGtSID09PSAtZCBhbHdheXMgZGVsZXRlLlxuICAgIGlmIChpUiAhPT0gZCAmJiBhSW5kZXhlc1JbaVJdIDwgYUluZGV4UHJldjEpIHtcbiAgICAgIGFGaXJzdCA9IGFJbmRleGVzUltpUl07IC8vIHZlcnRpY2FsIHRvIGluc2VydCBmcm9tIGJcbiAgICB9IGVsc2Uge1xuICAgICAgYUZpcnN0ID0gYUluZGV4UHJldjEgLSAxOyAvLyBob3Jpem9udGFsIHRvIGRlbGV0ZSBmcm9tIGFcblxuICAgICAgaWYgKGFGaXJzdCA8IGFTdGFydCkge1xuICAgICAgICAvLyBPcHRpbWl6YXRpb246IGRlbGV0ZSBtb3ZlZCBwYXN0IGxlZnQgb2YgZ3JhcGguXG4gICAgICAgIHJldHVybiBpUiAtIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVG8gZ2V0IGxhc3QgcG9pbnQgb2YgcGF0aCBzZWdtZW50LCBtb3ZlIGFsb25nIGRpYWdvbmFsIG9mIGNvbW1vbiBpdGVtcy5cbiAgICBhSW5kZXhQcmV2MSA9IGFJbmRleGVzUltpUl07XG4gICAgYUluZGV4ZXNSW2lSXSA9XG4gICAgICBhRmlyc3QgLVxuICAgICAgY291bnRDb21tb25JdGVtc1IoXG4gICAgICAgIGFTdGFydCxcbiAgICAgICAgYUZpcnN0IC0gMSxcbiAgICAgICAgYlN0YXJ0LFxuICAgICAgICBiUiArIGFGaXJzdCAtIGtSIC0gMSxcbiAgICAgICAgaXNDb21tb25cbiAgICAgICk7XG4gIH1cbiAgcmV0dXJuIGlNYXhSO1xufTtcblxuLy8gQSBjb21wbGV0ZSBmdW5jdGlvbiB0byBleHRlbmQgZm9yd2FyZCBwYXRocyBmcm9tIChkIC0gMSkgdG8gZCBjaGFuZ2VzLlxuLy8gUmV0dXJuIHRydWUgaWYgYSBwYXRoIG92ZXJsYXBzIHJldmVyc2UgcGF0aCBvZiAoZCAtIDEpIGNoYW5nZXMgaW4gaXRzIGRpYWdvbmFsLlxuY29uc3QgZXh0ZW5kT3ZlcmxhcHBhYmxlUGF0aHNGID0gKFxuICBkLFxuICBhU3RhcnQsXG4gIGFFbmQsXG4gIGJTdGFydCxcbiAgYkVuZCxcbiAgaXNDb21tb24sXG4gIGFJbmRleGVzRixcbiAgaU1heEYsXG4gIGFJbmRleGVzUixcbiAgaU1heFIsXG4gIGRpdmlzaW9uIC8vIHVwZGF0ZSBwcm9wIHZhbHVlcyBpZiByZXR1cm4gdHJ1ZVxuKSA9PiB7XG4gIGNvbnN0IGJGID0gYlN0YXJ0IC0gYVN0YXJ0OyAvLyBiSW5kZXggPSBiRiArIGFJbmRleCAtIGtGXG4gIGNvbnN0IGFMZW5ndGggPSBhRW5kIC0gYVN0YXJ0O1xuICBjb25zdCBiTGVuZ3RoID0gYkVuZCAtIGJTdGFydDtcbiAgY29uc3QgYmFEZWx0YUxlbmd0aCA9IGJMZW5ndGggLSBhTGVuZ3RoOyAvLyBrRiA9IGtSIC0gYmFEZWx0YUxlbmd0aFxuXG4gIC8vIFJhbmdlIG9mIGRpYWdvbmFscyBpbiB3aGljaCBmb3J3YXJkIGFuZCByZXZlcnNlIHBhdGhzIG1pZ2h0IG92ZXJsYXAuXG4gIGNvbnN0IGtNaW5PdmVybGFwRiA9IC1iYURlbHRhTGVuZ3RoIC0gKGQgLSAxKTsgLy8gLShkIC0gMSkgPD0ga1JcbiAgY29uc3Qga01heE92ZXJsYXBGID0gLWJhRGVsdGFMZW5ndGggKyAoZCAtIDEpOyAvLyBrUiA8PSAoZCAtIDEpXG5cbiAgbGV0IGFJbmRleFByZXYxID0gTk9UX1lFVF9TRVQ7IC8vIHByZXYgdmFsdWUgb2YgW2lGIC0gMV0gaW4gbmV4dCBpdGVyYXRpb25cblxuICAvLyBPcHRpbWl6YXRpb246IHNraXAgZGlhZ29uYWxzIGluIHdoaWNoIHBhdGhzIGNhbm5vdCBldmVyIG92ZXJsYXAuXG4gIGNvbnN0IG5GID0gZCA8IGlNYXhGID8gZCA6IGlNYXhGO1xuXG4gIC8vIFRoZSBkaWFnb25hbHMga0YgPSAyICogaUYgLSBkIGFyZSBvZGQgd2hlbiBkIGlzIG9kZCBhbmQgZXZlbiB3aGVuIGQgaXMgZXZlbi5cbiAgZm9yIChsZXQgaUYgPSAwLCBrRiA9IC1kOyBpRiA8PSBuRjsgaUYgKz0gMSwga0YgKz0gMikge1xuICAgIC8vIFRvIGdldCBmaXJzdCBwb2ludCBvZiBwYXRoIHNlZ21lbnQsIG1vdmUgb25lIGNoYW5nZSBpbiBmb3J3YXJkIGRpcmVjdGlvblxuICAgIC8vIGZyb20gbGFzdCBwb2ludCBvZiBwcmV2aW91cyBwYXRoIHNlZ21lbnQgaW4gYW4gYWRqYWNlbnQgZGlhZ29uYWwuXG4gICAgLy8gSW4gZmlyc3QgaXRlcmF0aW9uIHdoZW4gaUYgPT09IDAgYW5kIGtGID09PSAtZCBhbHdheXMgaW5zZXJ0LlxuICAgIC8vIEluIGxhc3QgcG9zc2libGUgaXRlcmF0aW9uIHdoZW4gaUYgPT09IGQgYW5kIGtGID09PSBkIGFsd2F5cyBkZWxldGUuXG4gICAgY29uc3QgaW5zZXJ0ID0gaUYgPT09IDAgfHwgKGlGICE9PSBkICYmIGFJbmRleFByZXYxIDwgYUluZGV4ZXNGW2lGXSk7XG4gICAgY29uc3QgYUxhc3RQcmV2ID0gaW5zZXJ0ID8gYUluZGV4ZXNGW2lGXSA6IGFJbmRleFByZXYxO1xuICAgIGNvbnN0IGFGaXJzdCA9IGluc2VydFxuICAgICAgPyBhTGFzdFByZXYgLy8gdmVydGljYWwgdG8gaW5zZXJ0IGZyb20gYlxuICAgICAgOiBhTGFzdFByZXYgKyAxOyAvLyBob3Jpem9udGFsIHRvIGRlbGV0ZSBmcm9tIGFcblxuICAgIC8vIFRvIGdldCBsYXN0IHBvaW50IG9mIHBhdGggc2VnbWVudCwgbW92ZSBhbG9uZyBkaWFnb25hbCBvZiBjb21tb24gaXRlbXMuXG4gICAgY29uc3QgYkZpcnN0ID0gYkYgKyBhRmlyc3QgLSBrRjtcbiAgICBjb25zdCBuQ29tbW9uRiA9IGNvdW50Q29tbW9uSXRlbXNGKFxuICAgICAgYUZpcnN0ICsgMSxcbiAgICAgIGFFbmQsXG4gICAgICBiRmlyc3QgKyAxLFxuICAgICAgYkVuZCxcbiAgICAgIGlzQ29tbW9uXG4gICAgKTtcbiAgICBjb25zdCBhTGFzdCA9IGFGaXJzdCArIG5Db21tb25GO1xuICAgIGFJbmRleFByZXYxID0gYUluZGV4ZXNGW2lGXTtcbiAgICBhSW5kZXhlc0ZbaUZdID0gYUxhc3Q7XG4gICAgaWYgKGtNaW5PdmVybGFwRiA8PSBrRiAmJiBrRiA8PSBrTWF4T3ZlcmxhcEYpIHtcbiAgICAgIC8vIFNvbHZlIGZvciBpUiBvZiByZXZlcnNlIHBhdGggd2l0aCAoZCAtIDEpIGNoYW5nZXMgaW4gZGlhZ29uYWwga0Y6XG4gICAgICAvLyBrUiA9IGtGICsgYmFEZWx0YUxlbmd0aFxuICAgICAgLy8ga1IgPSAoZCAtIDEpIC0gMiAqIGlSXG4gICAgICBjb25zdCBpUiA9IChkIC0gMSAtIChrRiArIGJhRGVsdGFMZW5ndGgpKSAvIDI7XG5cbiAgICAgIC8vIElmIHRoaXMgZm9yd2FyZCBwYXRoIG92ZXJsYXBzIHRoZSByZXZlcnNlIHBhdGggaW4gdGhpcyBkaWFnb25hbCxcbiAgICAgIC8vIHRoZW4gdGhpcyBpcyB0aGUgbWlkZGxlIGNoYW5nZSBvZiB0aGUgaW5kZXggaW50ZXJ2YWxzLlxuICAgICAgaWYgKGlSIDw9IGlNYXhSICYmIGFJbmRleGVzUltpUl0gLSAxIDw9IGFMYXN0KSB7XG4gICAgICAgIC8vIFVubGlrZSB0aGUgTXllcnMgYWxnb3JpdGhtIHdoaWNoIGZpbmRzIG9ubHkgdGhlIG1pZGRsZSDigJxzbmFrZeKAnVxuICAgICAgICAvLyB0aGlzIHBhY2thZ2UgY2FuIGZpbmQgdHdvIGNvbW1vbiBzdWJzZXF1ZW5jZXMgcGVyIGRpdmlzaW9uLlxuICAgICAgICAvLyBMYXN0IHBvaW50IG9mIHByZXZpb3VzIHBhdGggc2VnbWVudCBpcyBvbiBhbiBhZGphY2VudCBkaWFnb25hbC5cbiAgICAgICAgY29uc3QgYkxhc3RQcmV2ID0gYkYgKyBhTGFzdFByZXYgLSAoaW5zZXJ0ID8ga0YgKyAxIDoga0YgLSAxKTtcblxuICAgICAgICAvLyBCZWNhdXNlIG9mIGludmFyaWFudCB0aGF0IGludGVydmFscyBwcmVjZWRpbmcgdGhlIG1pZGRsZSBjaGFuZ2VcbiAgICAgICAgLy8gY2Fubm90IGhhdmUgY29tbW9uIGl0ZW1zIGF0IHRoZSBlbmQsXG4gICAgICAgIC8vIG1vdmUgaW4gcmV2ZXJzZSBkaXJlY3Rpb24gYWxvbmcgYSBkaWFnb25hbCBvZiBjb21tb24gaXRlbXMuXG4gICAgICAgIGNvbnN0IG5Db21tb25SID0gY291bnRDb21tb25JdGVtc1IoXG4gICAgICAgICAgYVN0YXJ0LFxuICAgICAgICAgIGFMYXN0UHJldixcbiAgICAgICAgICBiU3RhcnQsXG4gICAgICAgICAgYkxhc3RQcmV2LFxuICAgICAgICAgIGlzQ29tbW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGFJbmRleFByZXZGaXJzdCA9IGFMYXN0UHJldiAtIG5Db21tb25SO1xuICAgICAgICBjb25zdCBiSW5kZXhQcmV2Rmlyc3QgPSBiTGFzdFByZXYgLSBuQ29tbW9uUjtcbiAgICAgICAgY29uc3QgYUVuZFByZWNlZGluZyA9IGFJbmRleFByZXZGaXJzdCArIDE7XG4gICAgICAgIGNvbnN0IGJFbmRQcmVjZWRpbmcgPSBiSW5kZXhQcmV2Rmlyc3QgKyAxO1xuICAgICAgICBkaXZpc2lvbi5uQ2hhbmdlUHJlY2VkaW5nID0gZCAtIDE7XG4gICAgICAgIGlmIChkIC0gMSA9PT0gYUVuZFByZWNlZGluZyArIGJFbmRQcmVjZWRpbmcgLSBhU3RhcnQgLSBiU3RhcnQpIHtcbiAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IG51bWJlciBvZiBwcmVjZWRpbmcgY2hhbmdlcyBpbiBmb3J3YXJkIGRpcmVjdGlvblxuICAgICAgICAgIC8vIGlzIGVxdWFsIHRvIG51bWJlciBvZiBpdGVtcyBpbiBwcmVjZWRpbmcgaW50ZXJ2YWwsXG4gICAgICAgICAgLy8gdGhlcmVmb3JlIGl0IGNhbm5vdCBjb250YWluIGFueSBjb21tb24gaXRlbXMuXG4gICAgICAgICAgZGl2aXNpb24uYUVuZFByZWNlZGluZyA9IGFTdGFydDtcbiAgICAgICAgICBkaXZpc2lvbi5iRW5kUHJlY2VkaW5nID0gYlN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpdmlzaW9uLmFFbmRQcmVjZWRpbmcgPSBhRW5kUHJlY2VkaW5nO1xuICAgICAgICAgIGRpdmlzaW9uLmJFbmRQcmVjZWRpbmcgPSBiRW5kUHJlY2VkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlzaW9uLm5Db21tb25QcmVjZWRpbmcgPSBuQ29tbW9uUjtcbiAgICAgICAgaWYgKG5Db21tb25SICE9PSAwKSB7XG4gICAgICAgICAgZGl2aXNpb24uYUNvbW1vblByZWNlZGluZyA9IGFFbmRQcmVjZWRpbmc7XG4gICAgICAgICAgZGl2aXNpb24uYkNvbW1vblByZWNlZGluZyA9IGJFbmRQcmVjZWRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aXNpb24ubkNvbW1vbkZvbGxvd2luZyA9IG5Db21tb25GO1xuICAgICAgICBpZiAobkNvbW1vbkYgIT09IDApIHtcbiAgICAgICAgICBkaXZpc2lvbi5hQ29tbW9uRm9sbG93aW5nID0gYUZpcnN0ICsgMTtcbiAgICAgICAgICBkaXZpc2lvbi5iQ29tbW9uRm9sbG93aW5nID0gYkZpcnN0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhU3RhcnRGb2xsb3dpbmcgPSBhTGFzdCArIDE7XG4gICAgICAgIGNvbnN0IGJTdGFydEZvbGxvd2luZyA9IGJGaXJzdCArIG5Db21tb25GICsgMTtcbiAgICAgICAgZGl2aXNpb24ubkNoYW5nZUZvbGxvd2luZyA9IGQgLSAxO1xuICAgICAgICBpZiAoZCAtIDEgPT09IGFFbmQgKyBiRW5kIC0gYVN0YXJ0Rm9sbG93aW5nIC0gYlN0YXJ0Rm9sbG93aW5nKSB7XG4gICAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBudW1iZXIgb2YgY2hhbmdlcyBpbiByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICAgIC8vIGlzIGVxdWFsIHRvIG51bWJlciBvZiBpdGVtcyBpbiBmb2xsb3dpbmcgaW50ZXJ2YWwsXG4gICAgICAgICAgLy8gdGhlcmVmb3JlIGl0IGNhbm5vdCBjb250YWluIGFueSBjb21tb24gaXRlbXMuXG4gICAgICAgICAgZGl2aXNpb24uYVN0YXJ0Rm9sbG93aW5nID0gYUVuZDtcbiAgICAgICAgICBkaXZpc2lvbi5iU3RhcnRGb2xsb3dpbmcgPSBiRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpdmlzaW9uLmFTdGFydEZvbGxvd2luZyA9IGFTdGFydEZvbGxvd2luZztcbiAgICAgICAgICBkaXZpc2lvbi5iU3RhcnRGb2xsb3dpbmcgPSBiU3RhcnRGb2xsb3dpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIEEgY29tcGxldGUgZnVuY3Rpb24gdG8gZXh0ZW5kIHJldmVyc2UgcGF0aHMgZnJvbSAoZCAtIDEpIHRvIGQgY2hhbmdlcy5cbi8vIFJldHVybiB0cnVlIGlmIGEgcGF0aCBvdmVybGFwcyBmb3J3YXJkIHBhdGggb2YgZCBjaGFuZ2VzIGluIGl0cyBkaWFnb25hbC5cbmNvbnN0IGV4dGVuZE92ZXJsYXBwYWJsZVBhdGhzUiA9IChcbiAgZCxcbiAgYVN0YXJ0LFxuICBhRW5kLFxuICBiU3RhcnQsXG4gIGJFbmQsXG4gIGlzQ29tbW9uLFxuICBhSW5kZXhlc0YsXG4gIGlNYXhGLFxuICBhSW5kZXhlc1IsXG4gIGlNYXhSLFxuICBkaXZpc2lvbiAvLyB1cGRhdGUgcHJvcCB2YWx1ZXMgaWYgcmV0dXJuIHRydWVcbikgPT4ge1xuICBjb25zdCBiUiA9IGJFbmQgLSBhRW5kOyAvLyBiSW5kZXggPSBiUiArIGFJbmRleCAtIGtSXG4gIGNvbnN0IGFMZW5ndGggPSBhRW5kIC0gYVN0YXJ0O1xuICBjb25zdCBiTGVuZ3RoID0gYkVuZCAtIGJTdGFydDtcbiAgY29uc3QgYmFEZWx0YUxlbmd0aCA9IGJMZW5ndGggLSBhTGVuZ3RoOyAvLyBrUiA9IGtGICsgYmFEZWx0YUxlbmd0aFxuXG4gIC8vIFJhbmdlIG9mIGRpYWdvbmFscyBpbiB3aGljaCBmb3J3YXJkIGFuZCByZXZlcnNlIHBhdGhzIG1pZ2h0IG92ZXJsYXAuXG4gIGNvbnN0IGtNaW5PdmVybGFwUiA9IGJhRGVsdGFMZW5ndGggLSBkOyAvLyAtZCA8PSBrRlxuICBjb25zdCBrTWF4T3ZlcmxhcFIgPSBiYURlbHRhTGVuZ3RoICsgZDsgLy8ga0YgPD0gZFxuXG4gIGxldCBhSW5kZXhQcmV2MSA9IE5PVF9ZRVRfU0VUOyAvLyBwcmV2IHZhbHVlIG9mIFtpUiAtIDFdIGluIG5leHQgaXRlcmF0aW9uXG5cbiAgLy8gT3B0aW1pemF0aW9uOiBza2lwIGRpYWdvbmFscyBpbiB3aGljaCBwYXRocyBjYW5ub3QgZXZlciBvdmVybGFwLlxuICBjb25zdCBuUiA9IGQgPCBpTWF4UiA/IGQgOiBpTWF4UjtcblxuICAvLyBUaGUgZGlhZ29uYWxzIGtSID0gZCAtIDIgKiBpUiBhcmUgb2RkIHdoZW4gZCBpcyBvZGQgYW5kIGV2ZW4gd2hlbiBkIGlzIGV2ZW4uXG4gIGZvciAobGV0IGlSID0gMCwga1IgPSBkOyBpUiA8PSBuUjsgaVIgKz0gMSwga1IgLT0gMikge1xuICAgIC8vIFRvIGdldCBmaXJzdCBwb2ludCBvZiBwYXRoIHNlZ21lbnQsIG1vdmUgb25lIGNoYW5nZSBpbiByZXZlcnNlIGRpcmVjdGlvblxuICAgIC8vIGZyb20gbGFzdCBwb2ludCBvZiBwcmV2aW91cyBwYXRoIHNlZ21lbnQgaW4gYW4gYWRqYWNlbnQgZGlhZ29uYWwuXG4gICAgLy8gSW4gZmlyc3QgaXRlcmF0aW9uIHdoZW4gaVIgPT09IDAgYW5kIGtSID09PSBkIGFsd2F5cyBpbnNlcnQuXG4gICAgLy8gSW4gbGFzdCBwb3NzaWJsZSBpdGVyYXRpb24gd2hlbiBpUiA9PT0gZCBhbmQga1IgPT09IC1kIGFsd2F5cyBkZWxldGUuXG4gICAgY29uc3QgaW5zZXJ0ID0gaVIgPT09IDAgfHwgKGlSICE9PSBkICYmIGFJbmRleGVzUltpUl0gPCBhSW5kZXhQcmV2MSk7XG4gICAgY29uc3QgYUxhc3RQcmV2ID0gaW5zZXJ0ID8gYUluZGV4ZXNSW2lSXSA6IGFJbmRleFByZXYxO1xuICAgIGNvbnN0IGFGaXJzdCA9IGluc2VydFxuICAgICAgPyBhTGFzdFByZXYgLy8gdmVydGljYWwgdG8gaW5zZXJ0IGZyb20gYlxuICAgICAgOiBhTGFzdFByZXYgLSAxOyAvLyBob3Jpem9udGFsIHRvIGRlbGV0ZSBmcm9tIGFcblxuICAgIC8vIFRvIGdldCBsYXN0IHBvaW50IG9mIHBhdGggc2VnbWVudCwgbW92ZSBhbG9uZyBkaWFnb25hbCBvZiBjb21tb24gaXRlbXMuXG4gICAgY29uc3QgYkZpcnN0ID0gYlIgKyBhRmlyc3QgLSBrUjtcbiAgICBjb25zdCBuQ29tbW9uUiA9IGNvdW50Q29tbW9uSXRlbXNSKFxuICAgICAgYVN0YXJ0LFxuICAgICAgYUZpcnN0IC0gMSxcbiAgICAgIGJTdGFydCxcbiAgICAgIGJGaXJzdCAtIDEsXG4gICAgICBpc0NvbW1vblxuICAgICk7XG4gICAgY29uc3QgYUxhc3QgPSBhRmlyc3QgLSBuQ29tbW9uUjtcbiAgICBhSW5kZXhQcmV2MSA9IGFJbmRleGVzUltpUl07XG4gICAgYUluZGV4ZXNSW2lSXSA9IGFMYXN0O1xuICAgIGlmIChrTWluT3ZlcmxhcFIgPD0ga1IgJiYga1IgPD0ga01heE92ZXJsYXBSKSB7XG4gICAgICAvLyBTb2x2ZSBmb3IgaUYgb2YgZm9yd2FyZCBwYXRoIHdpdGggZCBjaGFuZ2VzIGluIGRpYWdvbmFsIGtSOlxuICAgICAgLy8ga0YgPSBrUiAtIGJhRGVsdGFMZW5ndGhcbiAgICAgIC8vIGtGID0gMiAqIGlGIC0gZFxuICAgICAgY29uc3QgaUYgPSAoZCArIChrUiAtIGJhRGVsdGFMZW5ndGgpKSAvIDI7XG5cbiAgICAgIC8vIElmIHRoaXMgcmV2ZXJzZSBwYXRoIG92ZXJsYXBzIHRoZSBmb3J3YXJkIHBhdGggaW4gdGhpcyBkaWFnb25hbCxcbiAgICAgIC8vIHRoZW4gdGhpcyBpcyBhIG1pZGRsZSBjaGFuZ2Ugb2YgdGhlIGluZGV4IGludGVydmFscy5cbiAgICAgIGlmIChpRiA8PSBpTWF4RiAmJiBhTGFzdCAtIDEgPD0gYUluZGV4ZXNGW2lGXSkge1xuICAgICAgICBjb25zdCBiTGFzdCA9IGJGaXJzdCAtIG5Db21tb25SO1xuICAgICAgICBkaXZpc2lvbi5uQ2hhbmdlUHJlY2VkaW5nID0gZDtcbiAgICAgICAgaWYgKGQgPT09IGFMYXN0ICsgYkxhc3QgLSBhU3RhcnQgLSBiU3RhcnQpIHtcbiAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IG51bWJlciBvZiBjaGFuZ2VzIGluIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICAgICAgLy8gaXMgZXF1YWwgdG8gbnVtYmVyIG9mIGl0ZW1zIGluIHByZWNlZGluZyBpbnRlcnZhbCxcbiAgICAgICAgICAvLyB0aGVyZWZvcmUgaXQgY2Fubm90IGNvbnRhaW4gYW55IGNvbW1vbiBpdGVtcy5cbiAgICAgICAgICBkaXZpc2lvbi5hRW5kUHJlY2VkaW5nID0gYVN0YXJ0O1xuICAgICAgICAgIGRpdmlzaW9uLmJFbmRQcmVjZWRpbmcgPSBiU3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGl2aXNpb24uYUVuZFByZWNlZGluZyA9IGFMYXN0O1xuICAgICAgICAgIGRpdmlzaW9uLmJFbmRQcmVjZWRpbmcgPSBiTGFzdDtcbiAgICAgICAgfVxuICAgICAgICBkaXZpc2lvbi5uQ29tbW9uUHJlY2VkaW5nID0gbkNvbW1vblI7XG4gICAgICAgIGlmIChuQ29tbW9uUiAhPT0gMCkge1xuICAgICAgICAgIC8vIFRoZSBsYXN0IHBvaW50IG9mIHJldmVyc2UgcGF0aCBzZWdtZW50IGlzIHN0YXJ0IG9mIGNvbW1vbiBzdWJzZXF1ZW5jZS5cbiAgICAgICAgICBkaXZpc2lvbi5hQ29tbW9uUHJlY2VkaW5nID0gYUxhc3Q7XG4gICAgICAgICAgZGl2aXNpb24uYkNvbW1vblByZWNlZGluZyA9IGJMYXN0O1xuICAgICAgICB9XG4gICAgICAgIGRpdmlzaW9uLm5DaGFuZ2VGb2xsb3dpbmcgPSBkIC0gMTtcbiAgICAgICAgaWYgKGQgPT09IDEpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBwcmV2aW91cyBwYXRoIHNlZ21lbnQuXG4gICAgICAgICAgZGl2aXNpb24ubkNvbW1vbkZvbGxvd2luZyA9IDA7XG4gICAgICAgICAgZGl2aXNpb24uYVN0YXJ0Rm9sbG93aW5nID0gYUVuZDtcbiAgICAgICAgICBkaXZpc2lvbi5iU3RhcnRGb2xsb3dpbmcgPSBiRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVubGlrZSB0aGUgTXllcnMgYWxnb3JpdGhtIHdoaWNoIGZpbmRzIG9ubHkgdGhlIG1pZGRsZSDigJxzbmFrZeKAnVxuICAgICAgICAgIC8vIHRoaXMgcGFja2FnZSBjYW4gZmluZCB0d28gY29tbW9uIHN1YnNlcXVlbmNlcyBwZXIgZGl2aXNpb24uXG4gICAgICAgICAgLy8gTGFzdCBwb2ludCBvZiBwcmV2aW91cyBwYXRoIHNlZ21lbnQgaXMgb24gYW4gYWRqYWNlbnQgZGlhZ29uYWwuXG4gICAgICAgICAgY29uc3QgYkxhc3RQcmV2ID0gYlIgKyBhTGFzdFByZXYgLSAoaW5zZXJ0ID8ga1IgLSAxIDoga1IgKyAxKTtcblxuICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgaW52YXJpYW50IHRoYXQgaW50ZXJ2YWxzIGZvbGxvd2luZyB0aGUgbWlkZGxlIGNoYW5nZVxuICAgICAgICAgIC8vIGNhbm5vdCBoYXZlIGNvbW1vbiBpdGVtcyBhdCB0aGUgc3RhcnQsXG4gICAgICAgICAgLy8gbW92ZSBpbiBmb3J3YXJkIGRpcmVjdGlvbiBhbG9uZyBhIGRpYWdvbmFsIG9mIGNvbW1vbiBpdGVtcy5cbiAgICAgICAgICBjb25zdCBuQ29tbW9uRiA9IGNvdW50Q29tbW9uSXRlbXNGKFxuICAgICAgICAgICAgYUxhc3RQcmV2LFxuICAgICAgICAgICAgYUVuZCxcbiAgICAgICAgICAgIGJMYXN0UHJldixcbiAgICAgICAgICAgIGJFbmQsXG4gICAgICAgICAgICBpc0NvbW1vblxuICAgICAgICAgICk7XG4gICAgICAgICAgZGl2aXNpb24ubkNvbW1vbkZvbGxvd2luZyA9IG5Db21tb25GO1xuICAgICAgICAgIGlmIChuQ29tbW9uRiAhPT0gMCkge1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgcG9pbnQgb2YgcmV2ZXJzZSBwYXRoIHNlZ21lbnQgaXMgc3RhcnQgb2YgY29tbW9uIHN1YnNlcXVlbmNlLlxuICAgICAgICAgICAgZGl2aXNpb24uYUNvbW1vbkZvbGxvd2luZyA9IGFMYXN0UHJldjtcbiAgICAgICAgICAgIGRpdmlzaW9uLmJDb21tb25Gb2xsb3dpbmcgPSBiTGFzdFByZXY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFTdGFydEZvbGxvd2luZyA9IGFMYXN0UHJldiArIG5Db21tb25GOyAvLyBhRmlyc3RQcmV2XG4gICAgICAgICAgY29uc3QgYlN0YXJ0Rm9sbG93aW5nID0gYkxhc3RQcmV2ICsgbkNvbW1vbkY7IC8vIGJGaXJzdFByZXZcblxuICAgICAgICAgIGlmIChkIC0gMSA9PT0gYUVuZCArIGJFbmQgLSBhU3RhcnRGb2xsb3dpbmcgLSBiU3RhcnRGb2xsb3dpbmcpIHtcbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbjogbnVtYmVyIG9mIGNoYW5nZXMgaW4gZm9yd2FyZCBkaXJlY3Rpb25cbiAgICAgICAgICAgIC8vIGlzIGVxdWFsIHRvIG51bWJlciBvZiBpdGVtcyBpbiBmb2xsb3dpbmcgaW50ZXJ2YWwsXG4gICAgICAgICAgICAvLyB0aGVyZWZvcmUgaXQgY2Fubm90IGNvbnRhaW4gYW55IGNvbW1vbiBpdGVtcy5cbiAgICAgICAgICAgIGRpdmlzaW9uLmFTdGFydEZvbGxvd2luZyA9IGFFbmQ7XG4gICAgICAgICAgICBkaXZpc2lvbi5iU3RhcnRGb2xsb3dpbmcgPSBiRW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXZpc2lvbi5hU3RhcnRGb2xsb3dpbmcgPSBhU3RhcnRGb2xsb3dpbmc7XG4gICAgICAgICAgICBkaXZpc2lvbi5iU3RhcnRGb2xsb3dpbmcgPSBiU3RhcnRGb2xsb3dpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBHaXZlbiBpbmRleCBpbnRlcnZhbHMgYW5kIGlucHV0IGZ1bmN0aW9uIHRvIGNvbXBhcmUgaXRlbXMgYXQgaW5kZXhlcyxcbi8vIGRpdmlkZSBhdCB0aGUgbWlkZGxlIGNoYW5nZS5cbi8vXG4vLyBETyBOT1QgQ0FMTCBpZiBzdGFydCA9PT0gZW5kLCBiZWNhdXNlIGludGVydmFsIGNhbm5vdCBjb250YWluIGNvbW1vbiBpdGVtc1xuLy8gYW5kIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IHRoZSDigJxubyBvdmVybGFw4oCdIGVycm9yLlxuY29uc3QgZGl2aWRlID0gKFxuICBuQ2hhbmdlLFxuICBhU3RhcnQsXG4gIGFFbmQsXG4gIGJTdGFydCxcbiAgYkVuZCxcbiAgaXNDb21tb24sXG4gIGFJbmRleGVzRixcbiAgYUluZGV4ZXNSLFxuICBkaXZpc2lvbiAvLyBvdXRwdXRcbikgPT4ge1xuICBjb25zdCBiRiA9IGJTdGFydCAtIGFTdGFydDsgLy8gYkluZGV4ID0gYkYgKyBhSW5kZXggLSBrRlxuICBjb25zdCBiUiA9IGJFbmQgLSBhRW5kOyAvLyBiSW5kZXggPSBiUiArIGFJbmRleCAtIGtSXG4gIGNvbnN0IGFMZW5ndGggPSBhRW5kIC0gYVN0YXJ0O1xuICBjb25zdCBiTGVuZ3RoID0gYkVuZCAtIGJTdGFydDtcblxuICAvLyBCZWNhdXNlIGdyYXBoIGhhcyBzcXVhcmUgb3IgcG9ydHJhaXQgb3JpZW50YXRpb24sXG4gIC8vIGxlbmd0aCBkaWZmZXJlbmNlIGlzIG1pbmltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluc2VydCBmcm9tIGIuXG4gIC8vIENvcnJlc3BvbmRpbmcgZm9yd2FyZCBhbmQgcmV2ZXJzZSBkaWFnb25hbHMgaW4gZ3JhcGhcbiAgLy8gZGVwZW5kIG9uIGxlbmd0aCBkaWZmZXJlbmNlIG9mIHRoZSBzZXF1ZW5jZXM6XG4gIC8vIGtGID0ga1IgLSBiYURlbHRhTGVuZ3RoXG4gIC8vIGtSID0ga0YgKyBiYURlbHRhTGVuZ3RoXG4gIGNvbnN0IGJhRGVsdGFMZW5ndGggPSBiTGVuZ3RoIC0gYUxlbmd0aDtcblxuICAvLyBPcHRpbWl6YXRpb246IG1heCBkaWFnb25hbCBpbiBncmFwaCBpbnRlcnNlY3RzIGNvcm5lciBvZiBzaG9ydGVyIHNpZGUuXG4gIGxldCBpTWF4RiA9IGFMZW5ndGg7XG4gIGxldCBpTWF4UiA9IGFMZW5ndGg7XG5cbiAgLy8gSW5pdGlhbGl6ZSBubyBjaGFuZ2VzIHlldCBpbiBmb3J3YXJkIG9yIHJldmVyc2UgZGlyZWN0aW9uOlxuICBhSW5kZXhlc0ZbMF0gPSBhU3RhcnQgLSAxOyAvLyBhdCBvcGVuIHN0YXJ0IG9mIGludGVydmFsLCBvdXRzaWRlIGNsb3NlZCBzdGFydFxuICBhSW5kZXhlc1JbMF0gPSBhRW5kOyAvLyBhdCBvcGVuIGVuZCBvZiBpbnRlcnZhbFxuXG4gIGlmIChiYURlbHRhTGVuZ3RoICUgMiA9PT0gMCkge1xuICAgIC8vIFRoZSBudW1iZXIgb2YgY2hhbmdlcyBpbiBwYXRocyBpcyAyICogZCBpZiBsZW5ndGggZGlmZmVyZW5jZSBpcyBldmVuLlxuICAgIGNvbnN0IGRNaW4gPSAobkNoYW5nZSB8fCBiYURlbHRhTGVuZ3RoKSAvIDI7XG4gICAgY29uc3QgZE1heCA9IChhTGVuZ3RoICsgYkxlbmd0aCkgLyAyO1xuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9IGRNYXg7IGQgKz0gMSkge1xuICAgICAgaU1heEYgPSBleHRlbmRQYXRoc0YoZCwgYUVuZCwgYkVuZCwgYkYsIGlzQ29tbW9uLCBhSW5kZXhlc0YsIGlNYXhGKTtcbiAgICAgIGlmIChkIDwgZE1pbikge1xuICAgICAgICBpTWF4UiA9IGV4dGVuZFBhdGhzUihkLCBhU3RhcnQsIGJTdGFydCwgYlIsIGlzQ29tbW9uLCBhSW5kZXhlc1IsIGlNYXhSKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIElmIGEgcmV2ZXJzZSBwYXRoIG92ZXJsYXBzIGEgZm9yd2FyZCBwYXRoIGluIHRoZSBzYW1lIGRpYWdvbmFsLFxuICAgICAgICAvLyByZXR1cm4gYSBkaXZpc2lvbiBvZiB0aGUgaW5kZXggaW50ZXJ2YWxzIGF0IHRoZSBtaWRkbGUgY2hhbmdlLlxuICAgICAgICBleHRlbmRPdmVybGFwcGFibGVQYXRoc1IoXG4gICAgICAgICAgZCxcbiAgICAgICAgICBhU3RhcnQsXG4gICAgICAgICAgYUVuZCxcbiAgICAgICAgICBiU3RhcnQsXG4gICAgICAgICAgYkVuZCxcbiAgICAgICAgICBpc0NvbW1vbixcbiAgICAgICAgICBhSW5kZXhlc0YsXG4gICAgICAgICAgaU1heEYsXG4gICAgICAgICAgYUluZGV4ZXNSLFxuICAgICAgICAgIGlNYXhSLFxuICAgICAgICAgIGRpdmlzaW9uXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBudW1iZXIgb2YgY2hhbmdlcyBpbiBwYXRocyBpcyAyICogZCAtIDEgaWYgbGVuZ3RoIGRpZmZlcmVuY2UgaXMgb2RkLlxuICAgIGNvbnN0IGRNaW4gPSAoKG5DaGFuZ2UgfHwgYmFEZWx0YUxlbmd0aCkgKyAxKSAvIDI7XG4gICAgY29uc3QgZE1heCA9IChhTGVuZ3RoICsgYkxlbmd0aCArIDEpIC8gMjtcblxuICAgIC8vIFVucm9sbCBmaXJzdCBoYWxmIGl0ZXJhdGlvbiBzbyBsb29wIGV4dGVuZHMgdGhlIHJlbGV2YW50IHBhaXJzIG9mIHBhdGhzLlxuICAgIC8vIEJlY2F1c2Ugb2YgaW52YXJpYW50IHRoYXQgaW50ZXJ2YWxzIGhhdmUgbm8gY29tbW9uIGl0ZW1zIGF0IHN0YXJ0IG9yIGVuZCxcbiAgICAvLyBhbmQgbGltaXRhdGlvbiBub3QgdG8gY2FsbCBkaXZpZGUgd2l0aCBlbXB0eSBpbnRlcnZhbHMsXG4gICAgLy8gdGhlcmVmb3JlIGl0IGNhbm5vdCBiZSBjYWxsZWQgaWYgYSBmb3J3YXJkIHBhdGggd2l0aCBvbmUgY2hhbmdlXG4gICAgLy8gd291bGQgb3ZlcmxhcCBhIHJldmVyc2UgcGF0aCB3aXRoIG5vIGNoYW5nZXMsIGV2ZW4gaWYgZE1pbiA9PT0gMS5cbiAgICBsZXQgZCA9IDE7XG4gICAgaU1heEYgPSBleHRlbmRQYXRoc0YoZCwgYUVuZCwgYkVuZCwgYkYsIGlzQ29tbW9uLCBhSW5kZXhlc0YsIGlNYXhGKTtcbiAgICBmb3IgKGQgKz0gMTsgZCA8PSBkTWF4OyBkICs9IDEpIHtcbiAgICAgIGlNYXhSID0gZXh0ZW5kUGF0aHNSKFxuICAgICAgICBkIC0gMSxcbiAgICAgICAgYVN0YXJ0LFxuICAgICAgICBiU3RhcnQsXG4gICAgICAgIGJSLFxuICAgICAgICBpc0NvbW1vbixcbiAgICAgICAgYUluZGV4ZXNSLFxuICAgICAgICBpTWF4UlxuICAgICAgKTtcbiAgICAgIGlmIChkIDwgZE1pbikge1xuICAgICAgICBpTWF4RiA9IGV4dGVuZFBhdGhzRihkLCBhRW5kLCBiRW5kLCBiRiwgaXNDb21tb24sIGFJbmRleGVzRiwgaU1heEYpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gSWYgYSBmb3J3YXJkIHBhdGggb3ZlcmxhcHMgYSByZXZlcnNlIHBhdGggaW4gdGhlIHNhbWUgZGlhZ29uYWwsXG4gICAgICAgIC8vIHJldHVybiBhIGRpdmlzaW9uIG9mIHRoZSBpbmRleCBpbnRlcnZhbHMgYXQgdGhlIG1pZGRsZSBjaGFuZ2UuXG4gICAgICAgIGV4dGVuZE92ZXJsYXBwYWJsZVBhdGhzRihcbiAgICAgICAgICBkLFxuICAgICAgICAgIGFTdGFydCxcbiAgICAgICAgICBhRW5kLFxuICAgICAgICAgIGJTdGFydCxcbiAgICAgICAgICBiRW5kLFxuICAgICAgICAgIGlzQ29tbW9uLFxuICAgICAgICAgIGFJbmRleGVzRixcbiAgICAgICAgICBpTWF4RixcbiAgICAgICAgICBhSW5kZXhlc1IsXG4gICAgICAgICAgaU1heFIsXG4gICAgICAgICAgZGl2aXNpb25cbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYCR7cGtnfTogbm8gb3ZlcmxhcCBhU3RhcnQ9JHthU3RhcnR9IGFFbmQ9JHthRW5kfSBiU3RhcnQ9JHtiU3RhcnR9IGJFbmQ9JHtiRW5kfWBcbiAgKTtcbn07XG5cbi8vIEdpdmVuIGluZGV4IGludGVydmFscyBhbmQgaW5wdXQgZnVuY3Rpb24gdG8gY29tcGFyZSBpdGVtcyBhdCBpbmRleGVzLFxuLy8gcmV0dXJuIGJ5IG91dHB1dCBmdW5jdGlvbiB0aGUgbnVtYmVyIG9mIGFkamFjZW50IGl0ZW1zIGFuZCBzdGFydGluZyBpbmRleGVzXG4vLyBvZiBlYWNoIGNvbW1vbiBzdWJzZXF1ZW5jZS4gRGl2aWRlIGFuZCBjb25xdWVyIHdpdGggb25seSBsaW5lYXIgc3BhY2UuXG4vL1xuLy8gVGhlIGluZGV4IGludGVydmFscyBhcmUgaGFsZiBvcGVuIFtzdGFydCwgZW5kKSBsaWtlIGFycmF5IHNsaWNlIG1ldGhvZC5cbi8vIERPIE5PVCBDQUxMIGlmIHN0YXJ0ID09PSBlbmQsIGJlY2F1c2UgaW50ZXJ2YWwgY2Fubm90IGNvbnRhaW4gY29tbW9uIGl0ZW1zXG4vLyBhbmQgYmVjYXVzZSBkaXZpZGUgZnVuY3Rpb24gd2lsbCB0aHJvdyB0aGUg4oCcbm8gb3ZlcmxhcOKAnSBlcnJvci5cbmNvbnN0IGZpbmRTdWJzZXF1ZW5jZXMgPSAoXG4gIG5DaGFuZ2UsXG4gIGFTdGFydCxcbiAgYUVuZCxcbiAgYlN0YXJ0LFxuICBiRW5kLFxuICB0cmFuc3Bvc2VkLFxuICBjYWxsYmFja3MsXG4gIGFJbmRleGVzRixcbiAgYUluZGV4ZXNSLFxuICBkaXZpc2lvbiAvLyB0ZW1wb3JhcnkgbWVtb3J5LCBub3QgaW5wdXQgbm9yIG91dHB1dFxuKSA9PiB7XG4gIGlmIChiRW5kIC0gYlN0YXJ0IDwgYUVuZCAtIGFTdGFydCkge1xuICAgIC8vIFRyYW5zcG9zZSBncmFwaCBzbyBpdCBoYXMgcG9ydHJhaXQgaW5zdGVhZCBvZiBsYW5kc2NhcGUgb3JpZW50YXRpb24uXG4gICAgLy8gQWx3YXlzIGNvbXBhcmUgc2hvcnRlciB0byBsb25nZXIgc2VxdWVuY2UgZm9yIGNvbnNpc3RlbmN5IGFuZCBvcHRpbWl6YXRpb24uXG4gICAgdHJhbnNwb3NlZCA9ICF0cmFuc3Bvc2VkO1xuICAgIGlmICh0cmFuc3Bvc2VkICYmIGNhbGxiYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIExhemlseSB3cmFwIGNhbGxiYWNrIGZ1bmN0aW9ucyB0byBzd2FwIGFyZ3MgaWYgZ3JhcGggaXMgdHJhbnNwb3NlZC5cbiAgICAgIGNvbnN0IHtmb3VuZFN1YnNlcXVlbmNlLCBpc0NvbW1vbn0gPSBjYWxsYmFja3NbMF07XG4gICAgICBjYWxsYmFja3NbMV0gPSB7XG4gICAgICAgIGZvdW5kU3Vic2VxdWVuY2U6IChuQ29tbW9uLCBiQ29tbW9uLCBhQ29tbW9uKSA9PiB7XG4gICAgICAgICAgZm91bmRTdWJzZXF1ZW5jZShuQ29tbW9uLCBhQ29tbW9uLCBiQ29tbW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNDb21tb246IChiSW5kZXgsIGFJbmRleCkgPT4gaXNDb21tb24oYUluZGV4LCBiSW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0U3RhcnQgPSBhU3RhcnQ7XG4gICAgY29uc3QgdEVuZCA9IGFFbmQ7XG4gICAgYVN0YXJ0ID0gYlN0YXJ0O1xuICAgIGFFbmQgPSBiRW5kO1xuICAgIGJTdGFydCA9IHRTdGFydDtcbiAgICBiRW5kID0gdEVuZDtcbiAgfVxuICBjb25zdCB7Zm91bmRTdWJzZXF1ZW5jZSwgaXNDb21tb259ID0gY2FsbGJhY2tzW3RyYW5zcG9zZWQgPyAxIDogMF07XG5cbiAgLy8gRGl2aWRlIHRoZSBpbmRleCBpbnRlcnZhbHMgYXQgdGhlIG1pZGRsZSBjaGFuZ2UuXG4gIGRpdmlkZShcbiAgICBuQ2hhbmdlLFxuICAgIGFTdGFydCxcbiAgICBhRW5kLFxuICAgIGJTdGFydCxcbiAgICBiRW5kLFxuICAgIGlzQ29tbW9uLFxuICAgIGFJbmRleGVzRixcbiAgICBhSW5kZXhlc1IsXG4gICAgZGl2aXNpb25cbiAgKTtcbiAgY29uc3Qge1xuICAgIG5DaGFuZ2VQcmVjZWRpbmcsXG4gICAgYUVuZFByZWNlZGluZyxcbiAgICBiRW5kUHJlY2VkaW5nLFxuICAgIG5Db21tb25QcmVjZWRpbmcsXG4gICAgYUNvbW1vblByZWNlZGluZyxcbiAgICBiQ29tbW9uUHJlY2VkaW5nLFxuICAgIG5Db21tb25Gb2xsb3dpbmcsXG4gICAgYUNvbW1vbkZvbGxvd2luZyxcbiAgICBiQ29tbW9uRm9sbG93aW5nLFxuICAgIG5DaGFuZ2VGb2xsb3dpbmcsXG4gICAgYVN0YXJ0Rm9sbG93aW5nLFxuICAgIGJTdGFydEZvbGxvd2luZ1xuICB9ID0gZGl2aXNpb247XG5cbiAgLy8gVW5sZXNzIGVpdGhlciBpbmRleCBpbnRlcnZhbCBpcyBlbXB0eSwgdGhleSBtaWdodCBjb250YWluIGNvbW1vbiBpdGVtcy5cbiAgaWYgKGFTdGFydCA8IGFFbmRQcmVjZWRpbmcgJiYgYlN0YXJ0IDwgYkVuZFByZWNlZGluZykge1xuICAgIC8vIFJlY3Vyc2VseSBmaW5kIGFuZCByZXR1cm4gY29tbW9uIHN1YnNlcXVlbmNlcyBwcmVjZWRpbmcgdGhlIGRpdmlzaW9uLlxuICAgIGZpbmRTdWJzZXF1ZW5jZXMoXG4gICAgICBuQ2hhbmdlUHJlY2VkaW5nLFxuICAgICAgYVN0YXJ0LFxuICAgICAgYUVuZFByZWNlZGluZyxcbiAgICAgIGJTdGFydCxcbiAgICAgIGJFbmRQcmVjZWRpbmcsXG4gICAgICB0cmFuc3Bvc2VkLFxuICAgICAgY2FsbGJhY2tzLFxuICAgICAgYUluZGV4ZXNGLFxuICAgICAgYUluZGV4ZXNSLFxuICAgICAgZGl2aXNpb25cbiAgICApO1xuICB9XG5cbiAgLy8gUmV0dXJuIGNvbW1vbiBzdWJzZXF1ZW5jZXMgdGhhdCBhcmUgYWRqYWNlbnQgdG8gdGhlIG1pZGRsZSBjaGFuZ2UuXG4gIGlmIChuQ29tbW9uUHJlY2VkaW5nICE9PSAwKSB7XG4gICAgZm91bmRTdWJzZXF1ZW5jZShuQ29tbW9uUHJlY2VkaW5nLCBhQ29tbW9uUHJlY2VkaW5nLCBiQ29tbW9uUHJlY2VkaW5nKTtcbiAgfVxuICBpZiAobkNvbW1vbkZvbGxvd2luZyAhPT0gMCkge1xuICAgIGZvdW5kU3Vic2VxdWVuY2UobkNvbW1vbkZvbGxvd2luZywgYUNvbW1vbkZvbGxvd2luZywgYkNvbW1vbkZvbGxvd2luZyk7XG4gIH1cblxuICAvLyBVbmxlc3MgZWl0aGVyIGluZGV4IGludGVydmFsIGlzIGVtcHR5LCB0aGV5IG1pZ2h0IGNvbnRhaW4gY29tbW9uIGl0ZW1zLlxuICBpZiAoYVN0YXJ0Rm9sbG93aW5nIDwgYUVuZCAmJiBiU3RhcnRGb2xsb3dpbmcgPCBiRW5kKSB7XG4gICAgLy8gUmVjdXJzZWx5IGZpbmQgYW5kIHJldHVybiBjb21tb24gc3Vic2VxdWVuY2VzIGZvbGxvd2luZyB0aGUgZGl2aXNpb24uXG4gICAgZmluZFN1YnNlcXVlbmNlcyhcbiAgICAgIG5DaGFuZ2VGb2xsb3dpbmcsXG4gICAgICBhU3RhcnRGb2xsb3dpbmcsXG4gICAgICBhRW5kLFxuICAgICAgYlN0YXJ0Rm9sbG93aW5nLFxuICAgICAgYkVuZCxcbiAgICAgIHRyYW5zcG9zZWQsXG4gICAgICBjYWxsYmFja3MsXG4gICAgICBhSW5kZXhlc0YsXG4gICAgICBhSW5kZXhlc1IsXG4gICAgICBkaXZpc2lvblxuICAgICk7XG4gIH1cbn07XG5jb25zdCB2YWxpZGF0ZUxlbmd0aCA9IChuYW1lLCBhcmcpID0+IHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtwa2d9OiAke25hbWV9IHR5cGVvZiAke3R5cGVvZiBhcmd9IGlzIG5vdCBhIG51bWJlcmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXJnKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAke3BrZ306ICR7bmFtZX0gdmFsdWUgJHthcmd9IGlzIG5vdCBhIHNhZmUgaW50ZWdlcmApO1xuICB9XG4gIGlmIChhcmcgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCR7cGtnfTogJHtuYW1lfSB2YWx1ZSAke2FyZ30gaXMgYSBuZWdhdGl2ZSBpbnRlZ2VyYCk7XG4gIH1cbn07XG5jb25zdCB2YWxpZGF0ZUNhbGxiYWNrID0gKG5hbWUsIGFyZykgPT4ge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3BrZ306ICR7bmFtZX0gdHlwZW9mICR7dHlwZX0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxufTtcblxuLy8gQ29tcGFyZSBpdGVtcyBpbiB0d28gc2VxdWVuY2VzIHRvIGZpbmQgYSBsb25nZXN0IGNvbW1vbiBzdWJzZXF1ZW5jZS5cbi8vIEdpdmVuIGxlbmd0aHMgb2Ygc2VxdWVuY2VzIGFuZCBpbnB1dCBmdW5jdGlvbiB0byBjb21wYXJlIGl0ZW1zIGF0IGluZGV4ZXMsXG4vLyByZXR1cm4gYnkgb3V0cHV0IGZ1bmN0aW9uIHRoZSBudW1iZXIgb2YgYWRqYWNlbnQgaXRlbXMgYW5kIHN0YXJ0aW5nIGluZGV4ZXNcbi8vIG9mIGVhY2ggY29tbW9uIHN1YnNlcXVlbmNlLlxuZnVuY3Rpb24gZGlmZlNlcXVlbmNlKGFMZW5ndGgsIGJMZW5ndGgsIGlzQ29tbW9uLCBmb3VuZFN1YnNlcXVlbmNlKSB7XG4gIHZhbGlkYXRlTGVuZ3RoKCdhTGVuZ3RoJywgYUxlbmd0aCk7XG4gIHZhbGlkYXRlTGVuZ3RoKCdiTGVuZ3RoJywgYkxlbmd0aCk7XG4gIHZhbGlkYXRlQ2FsbGJhY2soJ2lzQ29tbW9uJywgaXNDb21tb24pO1xuICB2YWxpZGF0ZUNhbGxiYWNrKCdmb3VuZFN1YnNlcXVlbmNlJywgZm91bmRTdWJzZXF1ZW5jZSk7XG5cbiAgLy8gQ291bnQgY29tbW9uIGl0ZW1zIGZyb20gdGhlIHN0YXJ0IGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbi5cbiAgY29uc3QgbkNvbW1vbkYgPSBjb3VudENvbW1vbkl0ZW1zRigwLCBhTGVuZ3RoLCAwLCBiTGVuZ3RoLCBpc0NvbW1vbik7XG4gIGlmIChuQ29tbW9uRiAhPT0gMCkge1xuICAgIGZvdW5kU3Vic2VxdWVuY2UobkNvbW1vbkYsIDAsIDApO1xuICB9XG5cbiAgLy8gVW5sZXNzIGJvdGggc2VxdWVuY2VzIGNvbnNpc3Qgb2YgY29tbW9uIGl0ZW1zIG9ubHksXG4gIC8vIGZpbmQgY29tbW9uIGl0ZW1zIGluIHRoZSBoYWxmLXRyaW1tZWQgaW5kZXggaW50ZXJ2YWxzLlxuICBpZiAoYUxlbmd0aCAhPT0gbkNvbW1vbkYgfHwgYkxlbmd0aCAhPT0gbkNvbW1vbkYpIHtcbiAgICAvLyBJbnZhcmlhbnQ6IGludGVydmFscyBkbyBub3QgaGF2ZSBjb21tb24gaXRlbXMgYXQgdGhlIHN0YXJ0LlxuICAgIC8vIFRoZSBzdGFydCBvZiBhbiBpbmRleCBpbnRlcnZhbCBpcyBjbG9zZWQgbGlrZSBhcnJheSBzbGljZSBtZXRob2QuXG4gICAgY29uc3QgYVN0YXJ0ID0gbkNvbW1vbkY7XG4gICAgY29uc3QgYlN0YXJ0ID0gbkNvbW1vbkY7XG5cbiAgICAvLyBDb3VudCBjb21tb24gaXRlbXMgZnJvbSB0aGUgZW5kIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvbi5cbiAgICBjb25zdCBuQ29tbW9uUiA9IGNvdW50Q29tbW9uSXRlbXNSKFxuICAgICAgYVN0YXJ0LFxuICAgICAgYUxlbmd0aCAtIDEsXG4gICAgICBiU3RhcnQsXG4gICAgICBiTGVuZ3RoIC0gMSxcbiAgICAgIGlzQ29tbW9uXG4gICAgKTtcblxuICAgIC8vIEludmFyaWFudDogaW50ZXJ2YWxzIGRvIG5vdCBoYXZlIGNvbW1vbiBpdGVtcyBhdCB0aGUgZW5kLlxuICAgIC8vIFRoZSBlbmQgb2YgYW4gaW5kZXggaW50ZXJ2YWwgaXMgb3BlbiBsaWtlIGFycmF5IHNsaWNlIG1ldGhvZC5cbiAgICBjb25zdCBhRW5kID0gYUxlbmd0aCAtIG5Db21tb25SO1xuICAgIGNvbnN0IGJFbmQgPSBiTGVuZ3RoIC0gbkNvbW1vblI7XG5cbiAgICAvLyBVbmxlc3Mgb25lIHNlcXVlbmNlIGNvbnNpc3RzIG9mIGNvbW1vbiBpdGVtcyBvbmx5LFxuICAgIC8vIHRoZXJlZm9yZSB0aGUgb3RoZXIgdHJpbW1lZCBpbmRleCBpbnRlcnZhbCBjb25zaXN0cyBvZiBjaGFuZ2VzIG9ubHksXG4gICAgLy8gZmluZCBjb21tb24gaXRlbXMgaW4gdGhlIHRyaW1tZWQgaW5kZXggaW50ZXJ2YWxzLlxuICAgIGNvbnN0IG5Db21tb25GUiA9IG5Db21tb25GICsgbkNvbW1vblI7XG4gICAgaWYgKGFMZW5ndGggIT09IG5Db21tb25GUiAmJiBiTGVuZ3RoICE9PSBuQ29tbW9uRlIpIHtcbiAgICAgIGNvbnN0IG5DaGFuZ2UgPSAwOyAvLyBudW1iZXIgb2YgY2hhbmdlIGl0ZW1zIGlzIG5vdCB5ZXQga25vd25cbiAgICAgIGNvbnN0IHRyYW5zcG9zZWQgPSBmYWxzZTsgLy8gY2FsbCB0aGUgb3JpZ2luYWwgdW53cmFwcGVkIGZ1bmN0aW9uc1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgZm91bmRTdWJzZXF1ZW5jZSxcbiAgICAgICAgICBpc0NvbW1vblxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICAvLyBJbmRleGVzIGluIHNlcXVlbmNlIGEgb2YgbGFzdCBwb2ludHMgaW4gZnVydGhlc3QgcmVhY2hpbmcgcGF0aHNcbiAgICAgIC8vIGZyb20gb3V0c2lkZSB0aGUgc3RhcnQgYXQgdG9wIGxlZnQgaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uOlxuICAgICAgY29uc3QgYUluZGV4ZXNGID0gW05PVF9ZRVRfU0VUXTtcbiAgICAgIC8vIGZyb20gdGhlIGVuZCBhdCBib3R0b20gcmlnaHQgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uOlxuICAgICAgY29uc3QgYUluZGV4ZXNSID0gW05PVF9ZRVRfU0VUXTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBvbmUgb2JqZWN0IGFzIG91dHB1dCBvZiBhbGwgY2FsbHMgdG8gZGl2aWRlIGZ1bmN0aW9uLlxuICAgICAgY29uc3QgZGl2aXNpb24gPSB7XG4gICAgICAgIGFDb21tb25Gb2xsb3dpbmc6IE5PVF9ZRVRfU0VULFxuICAgICAgICBhQ29tbW9uUHJlY2VkaW5nOiBOT1RfWUVUX1NFVCxcbiAgICAgICAgYUVuZFByZWNlZGluZzogTk9UX1lFVF9TRVQsXG4gICAgICAgIGFTdGFydEZvbGxvd2luZzogTk9UX1lFVF9TRVQsXG4gICAgICAgIGJDb21tb25Gb2xsb3dpbmc6IE5PVF9ZRVRfU0VULFxuICAgICAgICBiQ29tbW9uUHJlY2VkaW5nOiBOT1RfWUVUX1NFVCxcbiAgICAgICAgYkVuZFByZWNlZGluZzogTk9UX1lFVF9TRVQsXG4gICAgICAgIGJTdGFydEZvbGxvd2luZzogTk9UX1lFVF9TRVQsXG4gICAgICAgIG5DaGFuZ2VGb2xsb3dpbmc6IE5PVF9ZRVRfU0VULFxuICAgICAgICBuQ2hhbmdlUHJlY2VkaW5nOiBOT1RfWUVUX1NFVCxcbiAgICAgICAgbkNvbW1vbkZvbGxvd2luZzogTk9UX1lFVF9TRVQsXG4gICAgICAgIG5Db21tb25QcmVjZWRpbmc6IE5PVF9ZRVRfU0VUXG4gICAgICB9O1xuXG4gICAgICAvLyBGaW5kIGFuZCByZXR1cm4gY29tbW9uIHN1YnNlcXVlbmNlcyBpbiB0aGUgdHJpbW1lZCBpbmRleCBpbnRlcnZhbHMuXG4gICAgICBmaW5kU3Vic2VxdWVuY2VzKFxuICAgICAgICBuQ2hhbmdlLFxuICAgICAgICBhU3RhcnQsXG4gICAgICAgIGFFbmQsXG4gICAgICAgIGJTdGFydCxcbiAgICAgICAgYkVuZCxcbiAgICAgICAgdHJhbnNwb3NlZCxcbiAgICAgICAgY2FsbGJhY2tzLFxuICAgICAgICBhSW5kZXhlc0YsXG4gICAgICAgIGFJbmRleGVzUixcbiAgICAgICAgZGl2aXNpb25cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChuQ29tbW9uUiAhPT0gMCkge1xuICAgICAgZm91bmRTdWJzZXF1ZW5jZShuQ29tbW9uUiwgYUVuZCwgYkVuZCk7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/diff-sequences/build/index.js\n");

/***/ })

};
;